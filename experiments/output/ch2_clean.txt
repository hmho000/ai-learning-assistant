从本章至第4 章讨论的线性表、栈、队列、串和数组都属于线性结构。线性结构是简
单且常用的数据结构，它的基本特点是除第一个数据元素无直接前驱、最后一个数据元素
无直接后继之外，其他每个数据元素都有一个前驱和一个后继。线性表是最基本且最常用
的一种线性结构，同时也是其他数据结构的基础，尤其单链表是贯穿整个数据结构课程的
基本结构。本章将讨论线性表的逻辑结构、存储结构和相关运算，以及线性表的应用实例。
本章所涉及的许多问题都具有一定的普遍性。因此，本章是整个课程的重点与核心内容，
也是后续章节的重要基础。
2.1　线性表的定义和特点
在所有的数据结构中，最典型、最常用的是线性表（Linear List）。
在日常生活中，线性表的例子比比皆是。例如，26 个英文字母的字母表：
(A, B, C, …, Z)
是一个线性表，表中的数据元素是单个字母。在稍复杂的线性表中，一个数据元素可以包含若
干个数据项。例如在第1 章中提到的学生基本信息表，每条学生记录为一个数据元素，包括学
号、姓名、性别、籍贯、专业等数据项。
由以上示例可以看出，它们的数据元素虽然不同，但同一线性表中的数据元素必定具有相
同的特性，即属于同一数据对象，相邻数据元素之间存在着序偶关系。
诸如此类由n（n ≥0）个数据特性相同的数据元素构成的有限序列，称为线性表。
线性表中元素的个数n（n ≥0）定义称为线性表的长度，当n = 0 时称之为空表。
对于非空的线性表，每个数据元素都有一个确定的位置，可表示为L= (a1, a2, …, ai - 1, ai, ai +1, …, 
an)。其中，L 是表名，a1 是第一个数据元素，也称表头元素；an 是最后一个数据元素，也称表
尾元素；ai - 1 处在ai 的前边，称为ai 的直接前驱；ai + 1 处在ai 的后边，称为ai 的直接后继；ai
是表中的第i 个数据元素，也称为结点；i 是数据元素ai 在线性表中的位序。
对于非空的线性表或线性结构，其特点是：
（1）顺序性（序列）：元素具有线性顺序，除第一个数据元素无前驱、最后一个数据元素无
线性表
第2章

20
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
后继之外，其他每个数据元素均有一个前驱和一个后继；
（2）有限性（有限）：元素个数有限，在计算机中处理的对象都是有限的；
（3）相同性（相同特性）：所有数据元素的类型相同，即数据元素来自于同一数据对象；
（4）抽象性（元素类型不确定）：数据元素的类型需要根据实际的具体问题而确定，在定义
中是不具体的，而是抽象的。
2.2　案例引入
案例2.1 ：一元多项式的运算。
在数学上，一个一元多项式Pn(x) 可按升幂写成：
Pn(x) = p0 + p1x + p2x2 + … + pnxn 
要求：实现两个一元多项式的相加、相减和相乘的运算。
实现两个多项式相关运算的前提是在计算机中有效地表示一元多项式，进而在此基础上设
计相关运算的算法。这个问题看似很复杂，我们通过学习本章中线性表的表示及其相关运算便
可以解决。
可以看出，一元多项式可由n + 1 个系数唯一确定，因此，可以将一元多项式Pn(x) 抽象为
一个由n+1 个元素组成的有序序列，该序列可用线性表P 来表示：
P = (p0, p1, p2, …, pn) 
这时，每一项的指数i 隐含在其系数pi 的索引中。
假设Qm(x) 是一元m 次多项式，同样可用线性表Q 来表示从中抽象出来的序列：
Q = (q0, q1, q2, …, qm) 
不失一般性，设m ≤ n，则两个多项式相加的结果Rn(x) = Pn(x) + Qm(x) 可用线性表R 表示：
R = ( p0 + q0, p1 + q1, p2 + q2, …, pm + qm, pm+1, …, pn) 
在后面的叙述中将看到，对此类多项式的线性表只需要用数组表示的顺序存储结构便很容
易实现上述运算。
然而，在通常的应用中，多项式的次数可能很高且变化很大，这种所谓的稀疏多项式如果
采用上述表示方法，将使得线性表中出现很多零元素。下面给出稀疏多项式的例子。
案例2.2 ：稀疏多项式的运算。
例如，在处理形如
S(x) = 1 + 3x10000 + 2x20000
的多项式时，就要用一个长度为20001 的线性表来表示，而表中仅有3 个非零元素，将会造成
存储空间的很大浪费，这种对空间的浪费是应当避免的。由于线性表中的元素可以包含多个数
据项，由此可改变元素设定，对多项式的每一项，可用“( 系数, 指数)”的形式唯一确定。
一般情况下的一元n 次多项式可写成：
Pn(x) = p1
1ex + p2
2ex + … + pm
m
ex
                                            （2-1）
其中，pi 是指数为ei 的项的非零系数，且满足：
0 ≤ e1 < e2 < … < em = n 
用一个长度为m 且每个元素有两个数据项（系数项和指数项）的线性表：
((p1, e1), (p2, e2),…,(pm, em)) 
                                     （2-2）
便可唯一确定多项式Pn(x)。在最坏情况下，n + 1（= m）个系数都不为0，则比只存储每项系数
的方案要多存储一倍的数据。但是，对于类似S(x) 的稀疏多项式，这种表示将大大节省空间。

21
第
2
章
 
线
性
表
由上述讨论可以看出，如果多项式属于非稀疏多项式，且只对多项式进行“求值”等不改
变多项式的系数和指数的运算，可采用数组表示的顺序存储结构。如果多项式属于稀疏多项式，
虽然可以采用数组表示法，但这种顺序存储结构的存储空间分配不够灵活。因为事先无法确定
多项式的非零项数，所以需要根据预期估计可能的最大值定义数组的大小，这种分配方式可能
会带来两种问题：一种是实际非零项数比较小，浪费了大量存储空间；另一种是实际非零项数
超过了最大值，存储空间不够。另外在实现多项式的相加运算时，还需要开辟一个新的数组保
存结果多项式，导致算法的空间复杂度较高。改进方案是利用链式存储结构表示多项式的有序
序列，这样灵活性更大些。
那么，如何利用链式存储结构表示由式（2-2）定义的多项式，并实现多项式的相关运算
呢？本章2.8 节将给出详细的介绍。
在实现一元多项式的运算时，选择顺序存储结构还是链式存储结构，需要从实际出发，具
体问题具体分析。若一元多项式的指数分布连续，顺序存储结构可能更为合适；若多项式较为
稀疏，则链式存储结构可能更具优势。马克思主义唯物论强调一切从实际出发，这是我们在认
识世界、改造世界过程中应遵循的基本要求。在利用各类算法解决实际问题时，我们需全面了
解问题的各个层面，深入分析问题特点，形成正确的问题认识，据此设计出既满足功能性又具
备高性能的算法。这一过程也体现了科学方法论在算法设计中的应用。
案例2.3 ：图书信息管理系统。
出版社有一些图书数据保存在一个文本文件
book.txt 中，为简单起见，在此假设每种图书只包括3
部分信息：ISBN（书号）、书名和价格，文件中的部
分图书数据如图2.1 所示。现要求实现一个图书信息
管理系统，包括以下6 个具体功能。
（1）查找：根据指定的ISBN 或书名查找相应图
书的有关信息，并返回该图书在表中的位置序号。
（2）插入：插入一条新的图书信息。
（3）删除：删除一条图书信息。
（4）修改：根据指定的ISBN，修改该图书的价格。
（5）排序：将图书按照价格由低到高进行排序。
（6）计数：统计文件中的图书数量。
要实现上述功能，与前面两个案例中的多项式一样，我们首先根据图书的特点将其抽象成
一个线性表，每本图书作为线性表中的一个元素，然后可以采用适当的存储结构来表示该线性
表，在此基础上设计完成有关的功能算法。具体采取哪种存储结构，可以根据两种不同存储结
构的优缺点，视实际情况而定。
可以看出，在工作和生活中的许多实际应用问题都会涉及图书信息管理案例中用到的这些
基本操作。这些问题中都包含n 个数据特性相同的元素，即可以表示为线性表。不同的问题所
涉元素的数据类型不尽相同，可以为简单数据类型（如案例2.1 所示的一元多项式表示），也可
以为复杂数据类型（如案例2.2 所示的稀疏多项式表示和案例2.3 中的图书数据），但这些问题
所涉及的基本操作都具有很大的相似性，如果为每个具体应用都编一个程序显然不是一种很好
的方法。解决这类问题的最好方法就是从具体应用中抽象出共性的逻辑结构和基本操作（抽象
数据类型），然后采用程序设计语言实现相应的存储结构和基本操作。
本章后续章节将依次给出线性表的抽象数据类型定义、线性表的顺序和链式存储结构的表
图2.1　文件中的部分图书数据

22
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
示及实现、线性表应用实例的实现。
学完本章后，案例2.3 的基本操作读者很容易就能实现。
2.3　线性表的类型定义
线性表是一种相当灵活的数据结构，其长度可根据需要增长或缩短，即对线性表的数据元
素不仅可以进行访问，而且可以进行插入和删除等操作。为不失一般性，本书采用1.2 节抽象数
据类型格式对各种数据结构进行描述。下面给出线性表的抽象数据类型定义：
ADT List{ 
　数据对象：D={ai|ai ∈ElemSet,i=1,2,…,n,n ≥0} 
　数据关系：R={<ai-1,ai>|ai-1,ai ∈D,i=2,…,n}
　基本操作： 
　　InitList(&L) 
　　　操作结果：构造一个空的线性表L。 
　　DestroyList(&L) 
　　　初始条件：线性表L已存在。 
　　　操作结果：销毁线性表L。 
　　ClearList(&L) 
　　　初始条件：线性表L已存在。 
　　　操作结果：将L重置为空表。 
　　ListEmpty(L) 
　　　初始条件：线性表L已存在。 
　　　操作结果：若L为空表，则返回true，否则返回false。
　　ListLength(L) 
　　　初始条件：线性表L已存在。 
　　　操作结果：返回L中数据元素的个数。 
　　GetElem(L,i,&e) 
　　　初始条件：线性表L已存在，且1 ≤i ≤ListLength(L)。 
　　　操作结果：用e返回L中第i个数据元素的值。 
　　LocateElem(L,e) 
　　　初始条件：线性表L已存在。 
　　　操作结果：返回L中第1个值与e相同的元素在L中的位置。若这样的数据元素不存在，则返回值为0。
　　PriorElem(L,cur_e,&pre_e) 
　　　初始条件：线性表L已存在。
　　　操作结果：若cur_e 是L 的数据元素，且不是第一个，则用pre_e 返回其前驱，否则操作失败，
pre_e 无定义。
　　NextElem(L,cur_e,&next_e) 
　　　初始条件：线性表L已存在。 
　　　操作结果：若cur_e 是L 的数据元素，且不是最后一个，则用next_e 返回其后继，否则操作失败，
next_e 无定义。 
　　ListInsert(&L,i,e) 
　　　初始条件：线性表L已存在，且1 ≤i ≤ListLength(L)+1。 
　　　操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。 
　　ListDelete(&L,i)
　　　初始条件：线性表L已存在且非空，且1 ≤i ≤ListLength(L)。 
　　　操作结果：删除L的第i个数据元素，L的长度减1。
　　TraverseList(L)
　　　初始条件：线性表L已存在。

23
第
2
章
 
线
性
表
　　　操作结果：对线性表L进行遍历，在遍历过程中对L的每个结点访问一次。
}ADT List 
（1）抽象数据类型仅是一个模型的定义，并不涉及模型的具体实现，因此这里描述中所
涉及的参数不必考虑具体数据类型。在实际应用中，数据元素可能有多种类型，到时可根据
具体需要选择使用不同的数据类型。
（2）上述抽象数据类型中给出的操作只是基本操作，由这些基本操作可以构成其他较复
杂的操作。例如，2.2 节中的案例，不论是一元多项式的运算还是图书的管理，首先都需要将
数据元素读入，生成一个包括所需数据的线性表，这属于线性表的创建。这项操作可首先调
用基本操作定义中的InitList(&L) 构造一个空的线性表L，然后反复调用ListInsert(&L, i, e)
在表中插入元素e，就可以创建一个需要的线性表。同样，对于一元多项式的运算可以看作
线性表的合并，合并过程需要不断地进行元素的插入操作。其他如线性表的拆分、复制等操
作也都可以利用上述基本操作的组合来实现。
（3）对于不同的应用，基本操作的接口可能不同。例如，案例2.3 中的删除操作，如果
要求删除其中ISBN 为x 的图书，首先需要根据x 确定该图书在线性表中的位置，然后利用
ListDelete(&L, i) 基本操作将该种图书记录从表中删除。
（4）由抽象数据类型定义的线性表，可以根据实际所采用的存储结构形式，进行具体的
表示和实现。
说明
2.4　线性表的顺序表示和实现 
2.4.1　线性表的顺序表示 
线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这
种表示也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为顺序表
（Sequential List）。其特点是，逻辑上相邻的数据元素，其物理位置也是相邻的。
假设线性表的每个元素需占用l 个存储单元，并以所占的第一个单元的存储地址作为数据
元素的存储起始位置，则线性表中第i + 1 个数据元素的存储位置LOC(ai + 1) 和第i 个数据元素
的存储位置LOC(ai) 之间满足下列关系：
LOC(ai + 1) = LOC(ai) + l
一般来说，线性表的第i 个数据元素ai 的存储位置为：
LOC(ai) = LOC(a1) + (i − 1) × l
式中，LOC(a1) 是线性表的第一个数据元素a1 的存储位置，通常称作线性表的起始位置或基地
址，表中相邻的元素ai 和ai + 1 的存储位置LOC(ai) 和LOC(ai + 1) 是相邻的。每一个数据元素的存
储位置都和线性表的起始位置相差一个常数，这个常数和数据元素在线性表中的位序成正比（见 
图2.2）。由此，只要确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取，所
以线性表的顺序存储结构是一种随机存取的存储结构。
由于高级程序设计语言中的数组类型也有随机存取的特性，因此，通常都用数组来描述数

24
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
据结构中的顺序存储结构。在此，由于线性表的长度可变，且所需最大存储空间随问题不同而
不同，则在C 语言中可用动态分配的一维数组表示线性表，描述如下：
存储地址
b
a1
a2
ai
n
i
2
1
an
b+l
b+(i-1)l
b+(n-1)l
b+(maxlen-1)l
b+nl
内存状态
数据元素在
线性表中的位序
空闲
…
…
…
…
…
…
…
图2.2　线性表的顺序存储结构示意
//- - - - - 顺序表的存储结构- - - - - 
#deﬁne MAXSIZE 100 
 
 
// 顺序表可能达到的最大长度
typedef struct
{ 
　 ElemType *elem; 
 
 
// 存储空间的基地址
　 int length;  
 
 
// 当前长度
}SqList; 
 
 
 
// 顺序表的结构类型为SqList
（1）数组空间通过后面的算法2.1 初始化动态分配得到，初始化完成后，数组指针elem
指示顺序表的基地址，数组空间大小为MAXSIZE。
（2）元素类型定义中的ElemType 数据类型是为了描述统一而自定的，在实际应用
中，用户可根据实际需要具体定义表中数据元素的数据类型，既可以是基本数据类型，如int、
float、char 等，也可以是构造数据类型，如struct 结构体类型。
（3）length 表示顺序表中当前数据元素的个数。因为C 语言数组的下标是从0 开始
的，而位置序号是从1 开始的，所以要注意区分元素的位置序号和该元素在数组中的下
标位置之间的对应关系，数据元素a1、a2、…、an 依次存放在数组elem[0]、elem[1]、…、
elem[length-1] 中。
说明
用顺序表存储案例2.2 的稀疏多项式数据时，其顺序存储分配情况如图2.3 所示。多项式的
顺序存储结构的类型定义如下：
 图2.3　稀疏多项式的顺序存储分配情况

25
第
2
章
 
线
性
表
#deﬁne MAXSIZE 100 
 
 
// 多项式可能达到的最大长度 
typedef struct  
 
 
// 多项式非零项的定义
{ 
　 ﬂoat　coef;  
 
 
// 系数 
　 int　 expn;  
 
 
// 指数 
}Polynomial;
typedef struct
{ 
　 Polynomial *elem;  
 
// 存储空间的基地址 
　 int length;  
 
 
// 多项式中当前项的个数 
}SqList; 
 
 
 
// 多项式的顺序存储结构类型为SqList
用顺序表存储案例2.3 的图书数据时，其顺序存储分配情况如图2.4 所示。图书表的顺序存
储结构的类型定义如下：
图2.4　图书数据的顺序存储分配情况
#deﬁne MAXSIZE 10000  
 
// 图书表可能达到的最大长度 
typedef struct  
 
 
// 图书信息定义
{ 
　 char no[20]; 
 
 
// 图书ISBN
　 char name[50]; 
 
 
// 图书名字
　 ﬂoat price;  
 
 
// 图书价格
}Book; 
typedef struct
{ 
　 Book *elem;  
 
 
// 存储空间的基地址 
　 int length;  
 
 
// 图书表中当前图书个数 
}SqList; 
 
 
 
// 图书表的顺序存储结构类型为SqList
在上述定义后，可以通过变量定义语句
SqList L;
将L 定义为SqList 类型的变量，便可以利用L.elem[i - 1] 访问表中位置序号为i 的图书记录。
2.4.2　顺序表中基本操作的实现
可以看出，当线性表以上述定义的顺序表表示时，某些操作很容易实现。因为表的长度是顺序表
的一个“属性”，所以可以通过返回length 的值实现求表长的操作，通过判断length 的值是否为0 判断
表是否为空，实现这些操作的算法的时间复杂度都是O(1)。下面讨论顺序表其他几个主要操作的实现。
1．初始化
顺序表的初始化操作就是构造一个空的顺序表。
算法2.1　顺序表的初始化
【算法步骤】
① 为顺序表L 动态分配一个预定义大小的数组空间，使elem 指向这段空
顺序表的初始化

26
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
间的基地址。
② 将表的当前长度设为0。
【算法描述】
Status InitList(SqList &L)
{// 构造一个空的顺序表L
　 L.elem=new ElemType[MAXSIZE];　  // 为顺序表分配一个大小为MAXSIZE 的数组空间 
　 if(!L.elem) exit(OVERFLOW);　　　 //存储分配失败退出
　 L.length=0;  
 
 
// 空表长度为0 
　 return OK; 
} 
动态分配线性表的存储区域可以更有效地利用系统的资源，当不需要该线性表时，可以使
用销毁操作及时释放占用的存储空间。
2．取值
取值操作是根据指定的位置序号i，获取顺序表中第i 个数据元素的值。
由于顺序存储结构具有随机存取的特点，可以直接通过数组下标定位得到，elem[i-1] 单元
存储第i 个数据元素。
算法2.2　顺序表的取值
【算法步骤】
① 判断指定的位置序号i 值是否合理（1 ≤i ≤L.length），若不合理，则
返回ERROR。
② 若i 值合理，则将第i 个数据元素L.elem[i-1] 赋给参数e，通过e 返回
第i 个数据元素的传值。
【算法描述】
Status GetElem(SqList L,int i,ElemType &e)
{
　 if (i<1||i>L.length) return ERROR; 
// 判断i值是否合理，若不合理，返
　　　　　　　　　　　　　　　　　　　　　　　　　　 回ERROR
　 e=L.elem[i-1]; 
 
 
 
//elem[i-1] 单元存储第i个数据
　　　　　　　　　　　　　　　　　　　　　　　　　　 元素
　 return OK;
}
【算法分析】
显然，顺序表取值算法的时间复杂度为O(1)。
3．查找
查找操作是根据指定的元素值e，查找顺序表中第1 个值与e 相等的元素。
若查找成功，则返回该元素在表中的位置序号；若查找失败，则返回0。
算法2.3　顺序表的查找
【算法步骤】
① 从第一个元素起，依次将其值和e 相比较，若找到值与e 相等的元素
L.elem[i]，则查找成功，返回该元素的序号i+1。
② 若查遍整个顺序表都没有找到，则查找失败，返回0。
顺序表的取值
顺序表的查找

27
第
2
章
 
线
性
表
【算法描述】
int LocateElem(SqList L,ElemType e)
{// 在顺序表L 中查找值为e的数据元素，返回其序号
　 for(i=0;i< L.length;i++) 
　　　if(L.elem[i]==e) return i+1;  
// 查找成功，返回序号i+1
　 return 0; 
 
 
 
 
// 查找失败，返回0
}
【算法分析】
当在顺序表中查找一个数据元素时，其时间主要耗费在数据的比较上，而比较的次数取决
于被查元素在线性表中的位置。
在查找时，为确定元素在顺序表中的位置，需和给定值进行比较的数据元素个数的期望值
称为查找算法在查找成功时的平均查找长度（Average Search Length，ASL)。
假设pi 是查找第i 个元素的概率，Ci 为找到表中其关键字与给定值相等的第i 个记录时，和
给定值已进行过比较的关键字个数，则在长度为n 的线性表中，查找成功时的平均查找长度为：
1
n
i
i
i
ASL
p C
=
=∑
                                                        （2-3）
从顺序表查找的过程可见，Ci 取决于所查元素在表中的位置。例如，查找表中第一个记录
时，仅需比较一次；而查找表中最后一个记录时，则需比较n 次。一般情况下Ci 等于i。
假设每个元素的查找概率相等，即：
pi = 1/n
则式（2-3）可简化为：
1
1
1
2
n
i
n
ASL
i
n
=
+
=
=
∑
                                                     （2-4）
由此可见，顺序表按值查找算法的平均时间复杂度为O(n)。
4．插入
线性表的插入操作是指在表的第i 个位置插入一个新的数据元素e，使长度为n 的线性表：
(a1, …, ai − 1, ai, …, an)
变成长度为n + 1 的线性表：
(a1, …, ai − 1, e, ai, …, an)
数据元素ai − 1 和ai 之间的逻辑关系发生了变化。在
线性表的顺序存储结构中，由于逻辑上相邻的数据元素在
物理位置上也是相邻的，因此，除非i = n+1，否则必须
移动元素才能反映这个逻辑关系的变化。
例如，图2.5 所示为一个线性表在插入前后数据元素
在存储空间中的位置变化。为了在线性表的第5 个位置上
插入一个值为25 的数据元素，则需将第5 个至第8 个数
据元素依次向后移动一个位置。
一般情况下，在第i（1 ≤i ≤n）个位置插入一个元
素时，需从最后一个元素即第n 个元素开始，依次向后移
动一个位置，直至第i 个元素（共n− i + 1 个元素）。
算法2.4　顺序表的插入
【算法步骤】
① 判断插入位置i 是否合法（i 值的合法范围是1 ≤i ≤n + 1），若不合法则返回ERROR。
序号
数据
元素
插入25
序号
1
12
13
21
24
28
30
42
77
12
13
21
24
25
28
30
42
77
2
3
4
5
6
7
8
1
2
3
4
5
6
7
8
9
数据
元素
 （b）插入后n = 9
（a）插入前n = 8
图2.5　线性表插入前后的状况

28
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
② 判断顺序表的存储空间是否已满，若满则返回ERROR。
③ 将第n 个至第i 个位置的元素依次向后移动一个位置，空出第i 个位置
（i = n + 1 时无须移动）。
④ 将要插入的新元素e 放入第i 个位置。
⑤ 表长加1。
【算法描述】
Status ListInsert(SqList &L,int i ,ElemType e)
{// 在顺序表L 中第i个位置插入新的元素e，i值的合法范围是1 ≤i ≤L.length+1
　 if((i<1)||(i>L.length+1)) return ERROR;  
//i值不合法 
　 if(L.length==MAXSIZE) return ERROR; 
 
//当前存储空间已满
　 for(j=L.length-1;j>=i-1;j--)　
　　　L.elem[j+1]=L.elem[j];　　　　　　　　　　　  
// 插入位置及之后的元素后移 
　 L.elem[i-1]=e;　　　　　　　　　　　　　　　　　 
//将新元素e放入第i个位置 
　 ++L.length;  
 
 
 
 
//表长加1 
　 return OK; 
}
 上述算法没有处理表的动态扩充，因此当表长已经达到预设的最大空间时，则不能再插入
元素。
【算法分析】
当在顺序表中某个位置上插入一个数据元素时，其时间主要耗费在移动元素上，而移动元
素的个数取决于插入元素的位置。
假设pi 是在第i 个元素之前插入一个元素的概率，Eins 为在长度为n 的线性表中插入一个元
素时所需移动元素次数的期望值（平均次数），则有：
1
ins
1
(
1)
n
i
i
E
p n
i
+
=
=
−+
∑
                                               （2-5）
不失一般性，可以假定在线性表的任何位置上插入元素都是等概率的，即：
1
1
ip
n
=
+
则式（2-5）可简化为：
1
ins
1
1
(
1)
1
2
n
i
n
E
n
i
n
+
=
=
−+
=
+ ∑
                                         （2-6）
由此可见，顺序表插入算法的平均时间复杂度为O(n)。
5．删除
线性表的删除操作是指将表的第i 个元素删去，将长
度为n 的线性表：
 (a1, …, ai − 1, ai, ai + 1, …, an)
变成长度为n−1 的线性表：
(a1, …, ai − 1, ai + 1, …, an)
数据元素ai − 1、ai 和ai + 1 之间的逻辑关系发生了变化，为
了在存储结构上反映这个变化，同样需要移动元素。如图
2.6 所示，为了删除第4 个数据元素，必须将第5 个至第8
个元素都依次向前移动一个位置。
一般情况下，删除第i（1 ≤i ≤n）个元素时需将第
图2.6　线性表删除前后的状况
顺序表的插入

29
第
2
章
 
线
性
表
i + 1 个至第n 个元素（共n − i 个元素）依次向前移动一个位置（i = n 时无须移动）。
算法2.5　顺序表的删除
【算法步骤】　
① 判断删除位置i 是否合法（合法值为1 ≤i ≤n），若不合法则返回
ERROR。
② 将第i + 1 个至第n 个元素依次向前移动一个位置（i = n 时无须 
移动） 。
③ 表长减1。
【算法描述】
Status ListDelete(SqList &L,int i)
{// 在顺序表L 中删除第i个元素，i值的合法范围是1 ≤i ≤L.length 
　 if((i<1)||(i>L.length)) return ERROR;  //i 值不合法 
　 for(j=i;j<=L.length-1;j++)　　　　　　　　　　
　　　L.elem[j-1]=L.elem[j];　　　　　　  
// 被删除元素之后的元素前移 
　 --L.length;　　　　　　　   
 
// 表长减1 
　 return OK; 
} 
【算法分析】
当在顺序表中某个位置上删除一个数据元素时，其时间主要耗费在移动元素上，而移动元
素的个数取决于删除元素的位置。
假设pi 是删除第i 个元素的概率，Edel 为在长度为n 的线性表中删除一个元素时所需移动元
素次数的期望值（平均次数），则有：
del
1
(
)
i
n
i
E
p n
i
=
=
−
∑
                                                          （2-7）
不失一般性，可以假定在线性表的任何位置上删除元素都是等概率的，即：
1
ip
n
=
则式（2-7）简化为：
del
1
1
1
=
(
)
2
n
i
n
E
n
i
n
=
−
−
=
∑
                                                  （2-8）
由此可见，顺序表删除算法的平均时间复杂度为O(n)。
顺序表可以随机存取表中任一元素，其存储位置可用一个简单、直观的公式来表示。然而，
从另一方面来看，这个特点也造成了这种存储结构的缺点：在做插入或删除操作时，需移动大
量元素。另外由于数组有长度相对固定的静态特性，当表中数据元素个数较多且变化较大时，
操作过程相对复杂，必然导致存储空间的浪费。所有这些问题，都可以通过线性表的另一种表
示方法——链式存储结构来解决。
2.5　线性表的链式表示和实现 
2.5.1　单链表的定义和表示 
线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储
单元可以是连续的，也可以是不连续的）。因此，为了表示每个数据元素ai 与其直接后继数据元
素ai + 1 之间的逻辑关系，对数据元素ai 来说，除了存储其本身的信息之外，还需存储一个指示
顺序表的删除

30
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
其直接后继的信息（直接后继的存储位置）。这两部分信息组成数据元素ai 的存储映像，称为结
点（node）。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的
域称为指针域。指针域中存储的信息称作指针或链。n 个结点[ai（1 ≤i ≤n）的存储映像] 链
接成一个链表，即为线性表：
(a1, a2, …, an)
的链式存储结构。又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表。
根据链表结点所含指针个数、指针指向和指针连接方式，可将链表分为单链表、循环链表、
双向链表、二叉链表、十字链表、邻接表、邻接多重表等。其中单链表、循环链表和双向链表
多用于实现线性表的链式存储结构，其他形式多用于实现树和图等非线性结构，最常见链表形
式是单链表。
本节先讨论单链表，例如，图2.7 所示为线性表的单链表存储结构，整个链表的存取必须
从头指针开始进行，头指针指示链表中第一个结点（第一个数据元素的存储映像，也称首元结
点）的存储位置。同时，由于最后一个数据元素没有直接后继，则单链表中最后一个结点的指
针为空（NULL）。
(ZHAO, QIAN, SUN, LI, ZHOU, WU, ZHENG, WANG)
 
图2.7　单链表存储结构
用单链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。换句话说，
指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要
求紧邻，由此，这种存储结构为非顺序映像或链式映像。
通常将链表画成用箭头相链接的结点的序列，结点之间的箭头表示链域中的指针。图2.7
所示的单链表可画成如图2.8 所示的形式，这是因为在使用链表时，关心的只是它所表示的线性
表中数据元素之间的逻辑顺序，而不是每个数据元素在存储器中的实际位置。
 
图2.8　单链表的逻辑状态
由上述可见，单链表可由头指针唯一确定。在C 语言中可用“结构指针”来描述：
//- - - - - 单链表的存储结构- - - - - 
typedef struct　LNode
{
　 ElemType　data;　　　　　　　　 
 
// 结点的数据域 
　 struct LNode　*next;　　　　　　 
 
//结点的指针域 
}LNode,*LinkList;　　　　　　　　　 
 
//LinkList 为指向结构体LNode的指针类型 

31
第
2
章
 
线
性
表
（1）这里定义的是单链表中每个结点的存储结构，它包括两部分：存储结点的数据域
data，其类型用通用类型标识符ElemType 表示（例如，用链表表示案例2.3 中的图书信息
时，只需将ElemType 替换为2.4.1 定义的Book 数据类型即可）；存储后继结点位置的指针
域next，其类型为指向结点的指针类型LNode *。
（2）为了提高程序的可读性，在此对同一结构体指针类型起了两个名称，LinkList 与
LNode *，两者本质上是等价的。通常习惯上用LinkList 定义单链表，强调定义的是某个单
链表的头指针；用LNode * 定义指向单链表中任意结点的指针变量。例如，若定义LinkList L，
则L 为单链表的头指针，若定义LNode *p，则p 为指向单链表中某个结点的指针，用*p 代
表该结点。当然也可以使用定义LinkList p，这种定义形式完全等价于LNode *p。
（3）单链表是由表头指针唯一确定的，因此单链表可以用头指针的名字来命名。若头指
针名是L，则简称该链表为表L。
（4）注意区分指针变量和结点变量两个不同的概念，若定义 LinkList p 或LNode *p，
则p 为指向某结点的指针变量，表示该结点的地址；而*p 为对应的结点变量，表示该结点的
名称。
说明
一般情况下，为了处理方便，在单链表的第一个结点之前附设一个结点，称之为头结点。
图2.8 所示的单链表增加头结点后如图2.9 所示。
 
图2.9　增加头结点的单链表的逻辑状态
下面对首元结点、头结点、头指针3 个容易混淆的概念加以说明。
（1）首元结点是指链表中存储第一个数据元素a1 的结点。如图2.8 或图2.9 所示的结点
“ZHAO”。
（2）头结点是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据
域可以不存储任何信息，也可存储与数据元素类型相同的其他附加信息。例如，当数据元素
为整型时，头结点的数据域中可存放该线性表的长度。
（3）头指针是指向链表中第一个结点的指针。若链表设有头结点，则头指针所指结点为
线性表的头结点；若链表不设头结点，则头指针所指结点为该线性表的首元结点。
说明
链表增加头结点的作用如下。
（1）便于首元结点的处理
增加了头结点后，首元结点的地址保存在头结点（其“前驱”结点）的指针域中，则对链
表的第一个数据元素的操作与对其他数据元素的操作相同，无须进行特殊处理。
（2）便于空表和非空表的统一处理
当链表不设头结点时，假设L 为单链表的头指针，它应该指向首元结点，则当单链表为长

32
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
度n 为0 的空表时， L 指针为空（判定空表的条件可记为：L = = NULL）。
增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。如图2.10（a）所
示的非空单链表，头指针指向头结点。若为空表，则头结点的指针域为空（判定空表的条件可
记为：L −>next = = NULL），如图2.10（b）所示。
图2.10　带头结点的单链表
在顺序表中，由于逻辑上相邻的两个元素在物理位置上紧邻，则每个元素的存储位置都可
从线性表的起始位置计算得到。而在单链表中，各个元素的存储位置都是随意的。然而，每个
元素的存储位置都包含在其直接前驱结点的信息之中。假设p 是指向单链表中第i 个数据元素
（结点ai，即数据域为ai 的结点）的指针，则p −>next 是指向第i + 1 个数据元素（结点ai + 1）的
指针。换句话说，若p −>data = ai，则p −>next−>data = ai + 1。由此，单链表是非随机存取的存
储结构，要取得第i 个数据元素必须从头指针出发顺链进行寻找，也称为顺序存取的存储结构。
因此，其基本操作的实现不同于顺序表。
2.5.2　单链表基本操作的实现 
1．初始化
单链表的初始化操作就是构造一个如图2.10（b）所示的空表。
算法2.6　单链表的初始化
【算法步骤】
① 生成新结点作为头结点，用头指针L 指向头结点。
② 头结点的指针域置空。
【算法描述】
Status InitList(LinkList &L)
{// 构造一个空的单链表L 
　 L=new LNode;　　　　//生成新结点作为头结点，用头指针L指向头结点 
　 L->next=NULL;　　　//头结点的指针域置空 
　 return OK; 
} 
2．取值
和顺序表不同，链表中逻辑相邻的结点并没有存储在物理相邻的单元中，这样，根据给定
的结点位置序号i，在链表中获取该结点的值不能像顺序表那样随机访问，而只能从链表的首元
结点出发，顺着链域next 逐个结点向下访问。
算法2.7　单链表的取值
【算法步骤】
① 用指针p 指向首元结点，用j 做计数器初值赋为1。
② 从首元结点开始依次顺着链域next 向下访问，只要指向当前结点的指
针p 不为空（NULL），并且没有到达序号为i 的结点，则循环执行以下操作：
 p 指向下一个结点；
 计数器j 相应加1。
单链表的初始化
单链表的取值

33
第
2
章
 
线
性
表
③ 退出循环时，如果指针p 为空，或者计数器j 大于i，说明指定的序号i 值不合法（i 大
于表长n 或i 小于等于0），取值失败返回ERROR ；否则取值成功，此时j = i 时，p 所指的结点
就是要找的第i 个结点，用参数e 保存当前结点的数据域，返回OK。
【算法描述】
Status GetElem(LinkList L,int i,ElemType &e)
{// 在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值
　 p=L->next;j=1;　   
 
// 初始化，p指向首元结点，计数器j初值赋为1
　 while(p&&j<i) 
 
 
// 顺链域向后查找，直到p为空或p指向第i个元素
　 { 
　　　p=p->next; 
 
 
//p 指向下一个结点
　　　++j; 
 
 
 
// 计数器j相应加1
　 }
　 if(!p||j>i)return ERROR;  
//i 值不合法i>n或i<=0 
　 e=p->data;  
 
 
// 取第i个结点的数据域
　 return OK; 
}
【算法分析】
该算法的基本操作是比较j 和i 并后移指针p，while 循环体中的语句频度与位置i 有关。若
1 ≤i ≤n，则频度为i − 1，一定能取值成功；若i > n，则频度为n，取值失败。因此算法2.7
的最坏时间复杂度为O(n)。
假设每个位置上元素的取值概率相等，即：
pi = 1/n
则：
 
1
1
1
(
1)
2
n
i
n
ASL              i
n
=
−
=
−
=
∑
                                                    （2-9）
由此可见，单链表取值算法的平均时间复杂度为O(n)。
3．查找
链表中按值查找的过程和顺序表类似，从链表的首元结点出发，依次将结
点值和给定值e 进行比较，返回查找结果。
算法2.8　单链表的按值查找
【算法步骤】
① 用指针p 指向首元结点。
② 从首元结点开始依次顺着链域next 向下查找，只要指向当前结点的指
针p 不为空，并且p 所指结点的数据域不等于给定值e，则循环执行以下操作：
p 指向下一个结点。
③ 返回p。若查找成功，p 此时指向结点的地址值，若查找失败，则p 的值为NULL。
【算法描述】
LNode *LocateElem(LinkList L,ElemType e)
{// 在带头结点的单链表L中查找值为e的元素 
　 p=L->next;  
 
  // 初始化，p指向首元结点
　 while(p && p->data!=e) 
  // 顺链域向后查找，直到p为空或p所指结点的数据域等于e
　　　p=p->next; 
 
  //p 指向下一个结点
　 return p; 
 
 
  // 查找成功返回值为e的结点地址p，查找失败p为NULL 
}
单链表的查找

34
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
【算法分析】
该算法的执行时间与待查找的值e 相关，其平均时间复杂度分析类似于算法2.7，也为O(n)。
4．插入
假设要在单链表的两个数据元素a 和b 之间插入一个数据元素x，已知p 为其单链表存储结
构中指向结点a 的指针，如图2.11（a）所示。
图2.11　在单链表中插入结点时指针变化状况
为插入数据元素x，首先要生成一个数据域为x 的结点，然后将之插入单链表中。根据插入
操作的逻辑定义，还需要修改结点a 中的指针域，令其指向结点x，而结点x 中的指针域应指向
结点b，从而实现3 个元素a、b 和x 之间逻辑关系的变化。插入后的单链表如图2.11（b）所示。
假设s 为指向结点x 的指针，则上述指针修改用语句描述即为：
s->next = p->next;　p->next = s;
算法2.9　单链表的插入
【算法步骤】
将值为e 的新结点插入表的第i 个结点的位置，即插入结点ai−1 与ai 之间，
具体插入过程如图2.12 所示，图中对应的5 个步骤说明如下。
① 查找结点ai−1 并由指针p 指向该结点。 
② 生成一个新结点*s。
③ 将新结点*s 的数据域置为e。 
④ 将新结点*s 的指针域指向结点ai。
⑤ 将结点*p 的指针域指向新结点*s。
【算法描述】
Status ListInsert(LinkList &L,int i,ElemType e)
{// 在带头结点的单链表L中第i个位置插入值为e的新结点
　 p=L;j=0; 
　 while(p && (j<i −1))
　　　{p=p->next;++j;}  
 
 
// 查找第i−1个结点，p指向该结点
　 if(!p||j>i −1) return ERROR; 
  
//i ＞n+1或者i ＜1
　 s=new LNode; 
 
 
 
// 生成新结点*s 
　 s->data=e;　　　　　　　　　　  
 
// 将结点*s的数据域置为e
　 s->next=p->next; 
 
 
 
// 将结点*s的指针域指向结点ai
　 p->next=s;  
 
 
 
// 将结点*p的指针域指向结点*s
　 return OK; 
}
和顺序表一样，如果表中有n 个结点，则插入操作中合法的插入位置有n + 1 个，即
1 ≤i ≤n + 1。当i = n + 1 时，新结点则插在链表尾部。
说明
单链表的插入

35
第
2
章
 
线
性
表
【算法分析】
单链表的插入操作虽然不需要像顺序表的插入操作那样移动元素，但平均时间复杂度仍为
O(n)。这是因为，为了在第i 个结点之前插入一个新结点，必须首先找到第i −1 个结点，其时间
复杂度与算法2.7 相同，为O(n)。
…
…
L
p
ai-1
ai
e
s
①
⑤
②
③
④
图2.12　在单链表第i 个位置上插入新结点的过程
5．删除
要删除单链表中指定位置的元素，同插入元素一样，首先应该找到该位置的前驱结点。如
图2.13 所示，在单链表中删除元素b 时，应该首先找到其前驱结点a。为了在单链表中实现元
素a、b 和c 之间逻辑关系的变化，仅需修改结点a 中的指针域即可。假设p 为指向结点a 的指
针，则修改指针的语句为：
p->next = p->next->next;
图2.13　在单链表中删除结点时指针的变化
但在删除结点b 时，除了修改结点a 的指针域外，还要释放结点b 所占的空间，所以在修
改指针前，应该引入另一指针q，临时保存结点b 的地址以备释放。
算法2.10　单链表的删除
【算法步骤】
删除单链表的第i 个结点ai 的具体过程如图2.14 所示，图中对应的4 个
步骤说明如下。
① 查找结点ai − 1 并由指针p 指向该结点。
② 临时保存待删除结点ai 的地址在q 中，以备释放。
③ 将结点*p 的指针域指向ai 的直接后继结点。
④ 释放结点ai 的空间。
【算法描述】
Status ListDelete(LinkList &L,int i)
{// 在带头结点的单链表L中，删除第i个元素
　 p=L;j=0; 
　 while((p->next) && (j<i-1)) 
 
// 查找第i−1个结点，p指向该结点
　　　{p=p->next; ++j;}
　 if(!(p->next)||(j>i-1)) return ERROR; 
// 当i>n或i<1时，删除位置不合理 
　 q=p->next;　　　　　　　　　　　　   
// 临时保存被删结点的地址以备释放 
　 p->next=q->next; 
 
 
 
// 改变删除结点前驱结点的指针域 
　 delete q;　　　　　　　　　　　　　   
// 释放删除结点的空间 
　 return OK; 
}
单链表的删除

36
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
删除算法中的循环条件（p->next&&j<i-1）和插入算法中的循环条件(p&&(j<i−1)) 是
有所区别的。因为插入操作中合法的插入位置有n+1 个，而删除操作中合法的删除位置只有n 
个，如果使用与插入操作相同的循环条件，则会出现引用空指针的情况，使删除操作失败。
说明
【算法分析】
类似于插入算法，删除算法时
间复杂度亦为O(n)。
6．创建单链表
算法2.6 的初始化操作是创建
一个只有一个头结点的空链表，而
上面链表的其他算法都是假定链表已经存在多个结点。那么，如何建立一个包括若干个结点的
链表呢？链表和顺序表不同，它是一种动态结构。整个可用存储空间可为多个链表共同享用，
每个链表占用的空间不需预先分配划定，而是由系统按需即时生成。因此，建立线性表的链式
存储结构的过程就是一个动态生成链表的过程。即从空表的初始状态起，依次建立各元素结点，
并逐个插入链表。
根据结点插入位置的不同，链表的创建方法可分为前插法和后插法。
（1）前插法
前插法是通过将新结点逐个插入链表的头部（头结点之后）来创建链表，每次申请一个新
结点，读入相应的数据元素值，然后将新结点插入到头结点之后。
算法2.11　前插法创建单链表
【算法步骤】
① 创建一个只有头结点的空链表。
② 根据待创建链表包括的元素个数n，循环n 次执行以下操作：
 生成一个新结点*p ；
 输入元素值赋给新结点*p 的数据域；
 将新结点*p 插入到头结点之后。
图2.15 所示为线性表（a, b, c, d, e）前插法的创建过程，因为每次插入在链表的头部，所以
应该逆位序输入数据，依次输入e、d、c、b、a，输入顺序和线性表中的逻辑顺序是相反的。
 
图2.15　前插法创建单链表
 
图2.14　删除单链表第i 个结点的过程
前插法创建 
单链表

37
第
2
章
 
线
性
表
【算法描述】
void CreateList_H(LinkList &L,int n)
{// 逆位序输入n 个元素的值，建立带表头结点的单链表L 
　 L=new LNode; 
　 L->next=NULL;  
 
 
 
　　//先建立一个带头结点的空链表 
　 for(i=0;i<n;++i)
　 {
　　 p=new LNode; 
 
 
 
　 //生成新结点*p
　　 cin>>p->data; 
 
 
 
　 //输入元素值赋给新结点*p的数据域
　　 p->next=L->next;L->next=p; 
 
　 //将新结点*p插入到头结点之后
　 }
}
显然，算法2.11 的时间复杂度为O(n)。
（2）后插法
后插法是通过将新结点逐个插入链表的尾部来创建链表。同前插法一样，每次申请一个新
结点，读入相应的数据元素值。不同的是，为了使新结点能够插入表尾，需要增加一个尾指针r
指向链表的尾结点。
算法2.12　后插法创建单链表
【算法步骤】
① 创建一个只有头结点的空链表。
② 尾指针r 初始化，指向头结点。
③ 根据创建链表包括的元素个数n，循环n 次执行以下操作：
 生成一个新结点*p ；
 输入元素值赋给新结点*p 的数据域；
 将新结点*p 插入尾结点*r 之后；
 尾指针r 指向新的尾结点*p。
图2.16 所示为线性表（a, b, c, d, e）后插法的创建过程，读入数据的顺序和线性表中的逻辑
顺序是相同的。
 
图2.16　后插法创建单链表
【算法描述】
void CreateList_R(LinkList &L,int n)
{// 正位序输入n 个元素的值，建立带表头结点的单链表L 
　 L=new LNode; 
　 L->next=NULL; 
 
 
 
　　//先建立一个带头结点的空链表 
　 r=L;  
 
 
  
 
　　//尾指针r指向头结点 
　 for(i=0;i<n;++i)
后插法创建 
单链表

38
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
　 { 
　　　p=new LNode; 
 
 
　　//生成新结点 
　　　cin>>p->data; 
 
 
　　//输入元素值赋给新结点*p的数据域
　　　p->next=NULL; r->next=p; 
　　//将新结点*p插入尾结点*r之后 
　　　r=p; 
 
 
 
　　//r指向新的尾结点*p
　 } 
} 
算法2.12 的时间复杂度亦为O(n)。
2.5.3　循环链表
循环链表（Circular Linked List）是另一种形式的链式存储结构。其特点是表中最后一个结
点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其他
结点，图2.17 所示为单链的循环链表。类似地，还可以有多重链的循环链表。
图2.17　单循环链表
循环单链表的操作和单链表基本一致，差别仅在于：当链表遍历时，判别当前指针p 是否
指向表尾结点的终止条件不同。在单链表中，判别条件为p!=NULL 或p->next!=NULL，而循环
单链表的判别条件为p!=L 或p->next!=L。
在某些情况下，若在循环链表中设立尾指针而不设头指针[ 见图2.18（a）]，可使一些操
作简化。例如，将两个线性表合并成一个表时，仅需将第一个表的尾指针指向第二个表的第一
个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点。当线性表以
图2.18（a）的循环链表作存储结构时，这个操作仅需改变两个指针值即可，主要语句段如下：
p = B->next->next; 
B->next = A->next;
 A->next = p;
上述操作的时间复杂度为O(1)，合并后的表如图2.18（b）所示。
图2.18　仅设尾指针的循环链表
2.5.4　双向链表
以上讨论的链式存储结构的结点中只有一个指示直接后继的指针域，由此，从某个结点出
发只能顺指针向后寻查其他结点。若要寻查结点的直接前驱，则必须从表头指针出发。换句话
说，在单链表中，查找直接后继的执行时间为O(1)，而查找直接前驱的执行时间为O(n)。为克
服单链表这种单向性的缺点，可利用双向链表（Double Linked List）。
顾名思义，在双向链表的结点中有两个指针域，一个指向直接后继，另一个指向直接前驱，
结点结构如图2.19（a）所示，在C 语言中可描述如下：

39
第
2
章
 
线
性
表
//- - - - - 双向链表的存储结构- - - - -
typedef struct DuLNode
{ 
　 ElemType data; 
 
 
// 数据域
　 struct DuLNode *prior; 
 
// 指向直接前驱
　 struct DuLNode *next; 
 
// 指向直接后继
}DuLNode,*DuLinkList; 
和单循环链表类似，双向链表也可以有循环表，如图2.19（c）所示，链表中存有两个环，
图2.19（b）所示为只有一个表头结点的空的双向循环链表。
图2.19　双向循环链表示例
在双向链表中，若d 为指向表中某一结点的指针（d 为DuLinkList 型变量），则显然有：
d->next->prior = d->prior->next = d
这个表示方式恰当地反映了这种结构的特性。
在双向链表中，有些操作（如ListLength、GetElem 和LocateElem 等）仅需涉及一个方向
的指针，则它们的算法描述和线性链表相同，但在插入、删除时有很大的不同，在双向链表中
进行插入、删除时需同时修改两个方向上的指针，图2.20 和图2.21 分别显示了插入和删除结点
时指针修改的情况。在插入结点时需要修改4 个指针，在删除结点时需要修改两个指针。它们
的实现分别如算法2.13 和算法2.14 所示，两者的时间复杂度均为O(n)。
　　　　
    图2.20　在双向链表中插入结点时指针的变化状况　　                       图2.21　在双向链表中删除结点时指针的变化状况
算法2.13　双向链表的插入
【算法描述】
Status ListInsert_DuL(DuLinkList &L,int i,ElemType e)
{// 在带头结点的双向链表L中第i个位置之前插入元素e
　 if(!(p=GetElem_DuL(L,i))) 　//在L中确定第i个元素的位置指针p
　　　return ERROR; 
 
　//p为NULL时，第i个元素不存在
　 s=new DuLNode; 
 
　//生成新结点*s
　 s->data=e;  
 
　//将结点*s数据域置为e
　 s->prior=p->prior;  
　//将结点*s插入L中，此步对应图2.20① 
　 p->prior->next=s;  
　//对应图2.20②
　 s->next=p;  
 
　//对应图2.20③
　 p->prior=s;  
 
　//对应图2.20④
　 return OK; 
}
双向链表的插入

40
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
算法2.14　双向链表的删除
【算法描述】
Status ListDelete_DuL(DuLinkList &L,int i)
{// 删除带头结点的双向链表L中的第i个元素
　 if(!(p=GetElem_DuL(L,i))) 　//在L中确定第i个元素的位置指针p 
　　　return ERROR; 
 
　//p为NULL时，第i个元素不存在 
　 p->prior->next=p->next; 
　//修改被删结点的前驱结点的后继指针，对
　　　　　　　　　　　　　　　　　　　应图2.21①
　 p->next->prior=p->prior; 　//修改被删结点的后继结点的前驱指针，对
　　　　　　　　　　　　　　　　　　  应图2.21②
　 delete p; 
 
 
　//释放被删结点的空间 
　 return OK; 
} 
2.6　顺序表和链表的比较 
前面两节介绍了线性表的两种存储结构：顺序表和链表。在实际应用中，不能笼统地说哪
种存储结构更好，由于它们各有优缺点，选用哪种存储结构，应根据具体问题作具体分析，通
常从空间性能和时间性能两个方面作比较分析。
2.6.1　空间性能的比较
（1）存储空间的分配
顺序表的存储空间必须预先分配，元素个数有一定限制，易造成存储空间浪费或空间溢出现
象；而链表不需要为其预先分配空间，只要内存空间允许，链表中的元素个数就没有限制。
基于此，当线性表的长度变化较大，难以预估存储规模时，宜采用链表作为存储结构。
（2）存储密度的大小
链表的每个结点除了设置数据域用来存储数据元素外，还要额外设置指针域，用来存储指
示元素之间逻辑关系的指针，从存储密度上来讲，这是不经济的。所谓存储密度是指数据元素
本身所占用的存储量和整个结点结构所占用的存储量之比，即：
 
= 数据元素本身占用的
存储密度
结点结构占
存储量
用的存储量
存储密度越大，存储空间的利用率就越高。显然，顺序表的存储密度为1，而链表的存储
密度小于1。如果每个元素数据域占据的空间较小，则指针的结构性开销就占用了整个结点的大
部分空间，这样存储密度较小。例如，若单链表的结点数据均为整数，指针所占用的空间和整
型量所占用的相同，则单链表的存储密度为0.5。因此，如果不考虑顺序表中的空闲区，则顺序
表的存储空间利用率为100%，而单链表的存储空间利用率仅为50%。
基于此，当线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用
顺序表作为存储结构。
2.6.2　时间性能的比较
（1）存取元素的效率
顺序表是由数组实现的，它是一种随机存取结构，指定任意一个位置序号i，都可以在O(1)
时间内直接存取该位置上的元素，即取值操作的效率高；而链表是一种顺序存取结构，按位置
双向链表的删除

41
第
2
章
 
线
性
表
访问链表中第i 个元素时，只能从表头开始依次向后遍历链表，直到找到第i 个位置上的元素，
时间复杂度为O(n)，即取值操作的效率低。
基于此，若线性表的主要操作是和元素位置紧密相关的一类取值操作，很少做插入或删除
时，宜采用顺序表作为存储结构。
（2）插入和删除操作的效率
对于链表，在确定插入或删除的位置后，插入或删除操作无须移动数据，只需要修改指针，
时间复杂度为O(1)。而对于顺序表，进行插入或删除时，平均要移动表中近一半的结点，时间
复杂度为O(n)。尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。
基于此，对于频繁进行插入或删除操作的线性表，宜采用链表作为存储结构。
2.7　线性表的应用 
2.7.1　线性表的合并
【例2.1】　求解一般集合的并集问题。
【问题描述】
已知两个集合A 和B，现要求一个新的集合A = A B。例如，设：
A = (7, 5, 3, 11)
B = (2, 6, 3)
合并后：
A = (7, 5, 3, 11, 2, 6)
【问题分析】
可以利用两个线性表LA 和LB 分别表示集合A 和B（线性表中的数据元素为集合中的成
员），这样只需扩大线性表LA，将存在于LB 中而不存在于LA 中的数据元素插入LA 中。只要
从LB 中依次取得每个数据元素，并依值在LA 中进行查访，若不存在，则插入之。
上述操作过程可用算法2.15 来描述。具体实现时既可采用顺序形式，也可采用链表形式。
算法2.15　线性表的合并
【算法步骤】
① 分别获取LA 表长m 和LB 表长n。
② 从LB 中第1 个数据元素开始，循环n 次执行以下操作：
 从LB 中查找第i（1 ≤i ≤n）个数据元素赋给e ；
 在LA 中查找元素e，如果不存在，则将e 插在表LA 的最后。
【算法描述】
void MergeList(List &LA,List LB)
{// 将所有在线性表LB中但不在LA中的数据元素插入LA中 
　 m=ListLength(LA); n=ListLength(LB); 
// 求线性表的长度 
　 for(i=1;i<=n;i++)  
 
 
 
 
　 {
　　　GetElem(LB,i,e);  
 
 
// 取LB中第i个数据元素赋给e
　　　if(!LocateElem(LA,e))  
 
//LA 中不存在和e相同的数据元素
　　　　 ListInsert(LA,++m,e); 
 
// 将e插在LA的最后
　 } 
}
线性表的合并

42
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
【算法分析】
上述算法的时间复杂度取决于抽象数据类型List 定义中基本操作的执行时间，假设LA 和
LB 的表长分别为m 和n，循环执行n 次，则：
① 当采用顺序存储结构时，在每次循环中，GetElem 和ListInsert 这两个操作的执行时间和表
长无关，LocateElem 的执行时间和表长m 成正比，因此，算法2.15 的时间复杂度为O(m × n) ；
② 当采用链式存储结构时，在每次循环中，GetElem 的执行时间和表长n 成正比，而
LocateElem 和ListInsert 这两个操作的执行时间和表长m 成正比，因此，若假设m 大于n，算法
2.15 的时间复杂度也为O(m × n)。
2.7.2　有序表的合并 
若线性表中的数据元素相互之间可以比较，并且数据元素在线性表中依值非递减或非递增
有序排列，则称该线性表为有序表（Ordered List）。
【例2.2】　求解有序集合的并集问题。
【问题描述】
有序集合是指集合中的元素有序排列。已知两个有序集合A 和B，数据元素按值非递减有
序排列，现要求一个新的集合C = A B，使集合C 中的数据元素仍按值非递减有序排列。 
例如，设：
A = (3, 5, 8, 11)
B = (2, 6, 8, 9, 11, 15, 20)
则：
C = (2, 3, 5, 6, 8, 8, 9, 11, 11, 15, 20)
【问题分析】
与例2.1 一样，可以利用两个线性表LA 和LB 分别表示集合A 和B，不同的是，此例中的
LA 和LB 有序，这样便没有必要从LB 中依次取得每个数据元素，到LA 中进行查访。
如果LA 和LB 两个表长分别记为m 和n，则合并后的新表LC 的表长应该为m + n。由于
LC 中的数据元素或是LA 中的元素，或是LB 中的元素，因此只要先设LC 为空表，然后将LA
或LB 中的元素逐个插入LC 中即可。为使LC 中的元素按值非递减有序排列，可设两个指针pa
和pb 分别指向LA 和LB 中的某个元素，若设pa 当前所指的元素为a，pb 当前所指的元素为b，
则当前应插入到LC 中的元素c 为：
a   a≤b
c
b   a>b

= 

 
显然，指针pa 和pb 初始时分别指向两个有序表的第一个元素，在所指元素插入LC 之后，
在LA 或LB 中顺序后移。
根据上述分析，分别给出有序表的顺序存储结构和链式存储结构相应合并算法的实现。
1．顺序有序表的合并
算法2.16　顺序有序表的合并
【算法步骤】
① 创建一个表长为m + n 的空表LC。
② 指针pc 初始化，指向LC 的第一个元素。
③ 指针pa 和pb 初始化，分别指向LA 和LB 的第一个元素。

43
第
2
章
 
线
性
表
④ 当指针pa 和pb 均未到达相应表尾时，则依次比较pa 和pb 所指向的元素值，从LA 或
LB 中“摘取”元素值较小的结点插入LC 的最后。
⑤ 如果pb 已到达LB 的表尾，依次将LA 的剩余元素插入LC 的最后。
⑥ 如果pa 已到达LA 的表尾，依次将LB 的剩余元素插入LC 的最后。
【算法描述】
void MergeList_Sq(SqList LA,SqList LB,SqList &LC)
{// 已知顺序有序表LA和LB的元素按值非递减排列 
 // 归并LA 和LB 得到新的顺序有序表LC，LC的元素也按值非递减排列
　 LC.length=LA.length+LB.length; 
// 新表长度为待合并两表的长度之和
　 LC.elem=new ElemType[LC.length]; 
// 为合并后的新表分配一个数组空间
　 pc=LC.elem; 
//指针pc指向新表的第一个元素
　 pa=LA.elem;　pb=LB.elem; 
//指针pa和pb的初值分别指向两个表的第一个元素
　 pa_last=LA.elem+LA.length-1; 
// 指针pa_last 指向LA的最后一个元素
　 pb_last=LB.elem+LB.length-1; 
// 指针pb_last 指向LB的最后一个元素
　 while((pa<=pa_last)&&(pb<=pb_last)) // 未达到LA和LB的表尾
　 { 
　　　if(*pa<=*pb) *pc++=*pa++; 
// 依次摘取两表中值较小的结点插入LC的最后 
　　　else *pc++=*pb++; 
　 } 
　 while(pa<=pa_last)　*pc++=*pa++; 
//已到达LB表尾，依次将LA的剩余元素插入LC的最后
　 while(pb<=pb_last)　*pc++=*pb++; 
//已到达LA表尾，依次将LB的剩余元素插入LC的最后
}
【算法分析】
若对算法2.16 中第一个循环语句的循环体进行如下修改：分出元素比较的第三种情况，当
*pa ==*pb 时，只将两者之一插入LC，则该算法完成的操作和算法2.15 相同，但时间复杂度却
不同。在算法2.16 中，由于LA 和LB 中元素依值非递减，则对LB 中的每个
元素，不需要在LA 中从表头至表尾进行全程搜索。如果两个表长分别记为m
和n，则算法2.16 循环最多执行的总次数为m + n。所以算法的时间复杂度为
O(m + n)。
此算法在归并时，需要开辟新的辅助空间，所以空间复杂度也为O(m + n)，
空间复杂度较高。利用链表来实现上述归并时，不需要开辟新的存储空间，可
以使空间复杂度达到最低。
2．链式有序表的合并
假设头指针为LA 和LB 的单链表分别为线性表LA 和LB 的存储结构，现要归并LA 和LB
得到单链表LC。因为链表结点之间的关系是通过指针指向建立起来的，所以用链表进行合并不
需要另外开辟存储空间，可以直接利用原来两个表的存储空间，合并过程中只需把LA 和LB 两
个表中的结点重新进行链接即可。
按照例2.2 给出的合并思想，需设立3 个指针pa、pb 和pc，其中pa 和pb 分别指向LA 和
LB 中当前待比较插入的结点，而pc 指向LC 中当前最后一个结点（LC 的表头结点设为LA 的
表头结点）。指针的初值为：pa 和pb 分别指向LA 和LB 表中的第一个结点，pc 指向空表LC 中
的头结点。同算法2.16 一样，通过比较指针pa 和pb 所指向的元素的值，依次从LA 或LB 中
摘取元素值较小的结点插入到LC 的最后，当其中一个表变空时，只要将另一个表的剩余段链接
在pc 所指结点之后即可。
顺序有序表的
合并

44
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
算法2.17　链式有序表的合并
【算法步骤】
① 指针pa 和pb 初始化，分别指向LA 和LB 的第一个结点。 
② LC 的结点取值为LA 的头结点。
③ 指针pc 初始化，指向LC 的头结点。
④ 当指针pa 和pb 均未到达相应表尾时，则依次比较pa 和pb 所指向的
元素值，从LA 或LB 中摘取元素值较小的结点插入LC 的最后。
⑤ 将非空表的剩余段插入pc 所指结点之后。
⑥ 释放LB 的头结点。
【算法描述】
void MergeList_L(LinkList &LA,LinkList &LB,LinkList &LC)
{// 已知单链表LA和LB的元素按值非递减排列
 // 归并LA 和LB得到新的单链表LC，LC的元素也按值非递减排列 
　 pa=LA->next;pb=LB->next;  
 
//pa 和pb的初值分别指向两个表的第一个结点 
　 LC=LA;　　　　　　　　　　   
 
// 用LA的头结点作为LC的头结点 
　 pc=LC;　　　　　　　　　　   
 
//pc的初值指向LC的头结点 
　 while(pa&&pb) 
 
 
 
　 {//LA 和LB均未到达表尾，依次“摘取”两表中值较小的结点插入到LC的最后
　　　if(pa->data<=pb->data)  
 
// 摘取pa所指结点
　　　{
　　　　 pc->next=pa;  
 
 
// 将pa所指结点链接到pc所指结点之后
　　　　 pc=pa;  
 
 
 
//pc 指向pa
　　　　 pa=pa->next;  
 
 
//pa 指向下一结点
　　　} 
　　　else 
 
 
 
 
// 摘取pb所指结点
　　　{
　　　　 pc->next=pb;  
 
 
// 将pb所指结点链接到pc所指结点之后
　　　　 pc=pb;  
 
 
 
//pc 指向pb
　　　　 pb=pb->next;  
 
 
//pb 指向下一结点
　　　} 
　 } 
 
 
 
 
 
//while
　　 pc->next=pa?pa:pb; 
 
 
// 将非空表的剩余段插入到pc所指结点之后
　　 delete LB; 
 
 
 
// 释放LB的头结点 
}
【算法分析】
可以看出，算法2.17 的时间复杂度和算法2.16 相同，但空间复杂度不同。在归并两个链
表为一个链表时，不需要另建新表的结点空间，而只需将原来两个链表中结点之间的关系解除，
重新按元素值非递减的关系将所有结点链接成一个链表即可，所以空间复杂度为O(1)。
2.8　案例分析与实现 
在2.2 节我们通过3 个典型案例引入了线性表这种数据结构，本节结合线性表的基本操作
对这3 个案例进行进一步的分析，然后给出案例中有关算法的具体实现。
链式有序表的
合并

45
第
2
章
 
线
性
表
案例2.1 ：一元多项式的运算。
【案例分析】
由2.2 节的讨论我们已知，一元多项式可以抽象成一个线性表。在计算机中，我们可以采
用数组来表示一元多项式的线性表。
利用数组p 表示：数组中每个分量p[i] 表示多项式每项的系数pi，数组分量的下标i 即对应
每项的指数。数组中非零的分量个数即多项式的项数。
例如，多项式P(x) = 10 + 5x − 4x2 + 3x3 + 2x4 可以用表2.1 所示的数组表示。
表2.1　多项式的数组表示
指数（下标i）
0
1
2
3
4
系数p[i]
10
5
-4
3
2
显然，利用上述方法表示一元多项式，多项式相加的算法很容易实现，只要把两个数组对
应的分量项相加就可以了。
案例2.2 ：稀疏多项式的运算。
【案例分析】
由2.2 节的讨论我们已知，稀疏多项式也可以抽象成一个线性表。结合2.7 节介绍的两个有
序表的归并方法，可以看出，稀疏多项式的相加过程和归并两个有序表的过程极其类似，不同
之处仅在于，后者在比较数据元素时只出现两种情况（小于等于、大于），而多项式的相加过程
在比较两个多项式指数时要考虑3 种情况（等于、小于、大于）。因此，多项式相加的过程可以
根据算法2.16 和算法2.17 改进而成。
和顺序存储结构相比，利用链式存储结构更加灵活，更适合表示一般的多项式，合并过程
的空间复杂度为O(1)，所以较为常用。本节将给出如何利用单链表的基本操作来实现多项式的
相加运算。
例如，图2.22 所示两个链表分别表示多项式A(x) = 7 + 3x + 9x8 + 5x17 和多项式B(x) = 8x + 
22x7 − 9x8。从图中可见，每个结点表示多项式中的一项。
图2.22　多项式的单链表存储结构
如何实现用这种单链表表示的多项式的加法运算呢？
根据多项式相加的运算规则：对于两个多项式中所有指数相同的项，对应系数相加，若其
和不为0，则作为“和多项式”中的一项插入“和多项式”链表中；对于两个多项式中指数不相
同的项，则将指数值较小的项插入“和多项式”链表中。“和多项式”链表中的结点无须生成，
而应该从两个多项式的链表中摘取。图2.22 所示的两个多项式相加得到的和多项式如图2.23 所
示，图中的长方框表示已被释放的结点。
图2.23　相加得到的和多项式
【案例实现】
用链表表示多项式时，每个链表结点存储多项式中的一个非零项，包括系数（coef）和指

46
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
数（expn）两个数据域以及一个指针域（next）。对应的数据结构定义为：
typedef struct PNode
{　 
　 ﬂoat　coef;  
 
 
 
// 系数 
　 int　 expn;  
 
 
 
// 指数 
　 struct PNode　*next; 
 
 
// 指针域
}PNode,*Polynomial; 
一个多项式可以表示成由这些结点链接起来的单链表，要实现多项式的相加运算，首先需
要创建多项式链表。
1．多项式的创建
多项式的创建方法类似于链表的创建方法，区别在于多项式链表是一个有序表，每项的位
置要经过比较才能确定。首先初始化一个空链表用来表示多项式，然后逐个输入各项，通过比
较，找到第一个大于该输入项指数的项，将输入项插到此项的前面，这样即可保证多项式链表
的有序性。
算法2.18　多项式的创建
【算法步骤】
① 创建一个只有头结点的空链表。
② 根据多项式的项的个数n，循环n 次执行以下操作：
 生成一个新结点*s ；
 输入多项式当前项的系数和指数赋给新结点*s 的数据域；
 设置一前驱指针pre，用于指向待找到的第一个大于输入项指数的结
点的前驱，pre 初始时指向头结点；
 指针q 初始化，指向首元结点；
 循环向下逐个比较链表中当前结点的指数与输入项的指数，找到第一
个大于输入项指数的结点*q ；
 将输入项结点*s 插入结点*q 之前。
【算法描述】
void CreatePolyn(Polynomial &P,int n)
{// 输入n 项的系数和指数，建立表示多项式的有序链表P
　 P=new PNode; 
　 P->next=NULL; 
 
 
// 先建立一个带头结点的单链表 
　 for(i=1;i<=n;++i)  
 
// 依次输入n个非零项
　 {
　　　s=new PNode; 
 
 
// 生成新结点 
　　　cin>>s->coef>>s->expn;  
// 输入系数和指数 
　　　pre=P; 
 
 
 
//pre 用于保存q的前驱，初值为头结点 
　　　q=P->next; 
 
 
//q 初始化，指向首元结点
　　　while(q&&q->expn<s->expn) 
// 通过比较指数找到第一个大于输入项指数的项*q
　　　{
　　　　 pre=q; 
　　　　 q=q->next; 
　　　}  
 
 
 
//while 
　　　s->next=q; 
 
 
// 将输入项s插入*q和其前驱结点pre之间 
　　　pre->next=s; 
　 } 
 
 
 
 
//for 
} 
多项式的创建

47
第
2
章
 
线
性
表
【算法分析】
创建一个项数为n 的有序多项式链表，需要执行n 次循环逐个输入各项，而每次循环又都
需要从前向后比较输入项与各项的指数。在最坏情况下，第n 次循环需要进行n 次比较，因此，
时间复杂度为O(n2)。
2．多项式的相加
创建两个多项式链表后，便可以进行多项式的加法运算了。假设头指针为Pa 和Pb 的单链
表分别为多项式A 和B 的存储结构，指针p1 和p2 分别指向A 和B 中当前进行比较的某个结
点，则逐一比较两个结点中的指数项，对于指数相同的项，对应系数相加，若其和不为0，则
插入“和多项式”链表中；对于指数不相同的项，则通过比较，将指数值较小的项插入“和
多项式”链表中。
算法2.19　多项式的相加
【算法步骤】
① 指针p1 和p2 初始化，分别指向Pa 和Pb 的首元结点。
② p3 指向和多项式的当前结点，初值为Pa 的头结点。
③ 当指针p1 和p2 均未到达相应表尾时，则循环比较p1 和p2 所指结点对应的指数值（p1-
>expn 与p2->expn），有下列3 种情况：
 
当p1->expn 等于p2->expn 时，则将两个结点中的系数相加，若和不为0，则修改p1
所指结点的系数值，同时删除p2 所指结点，若和为0，则删除p1 和p2 所指结点；
 
当p1->expn 小于p2->expn 时，则应摘取p1 所指结点插入“和多项
式”链表中；
 
当p1->expn 大于p2->expn 时，则应摘取p2 所指结点插入“和多项
式”链表中。
④ 将非空多项式的剩余段插入p3 所指结点之后。
⑤ 释放Pb 的头结点。
【算法描述】
void AddPolyn(Polynomial &Pa,Polynomial &Pb)
{// 多项式加法：Pa=Pa+Pb，利用两个多项式的结点构成“和多项式” 
　 p1=Pa->next; p2=Pb->next; 
//p1和p2初始时分别指向Pa和Pb的首元结点 
　 p3=Pa; 
//p3指向和多项式的当前结点，初值为Pa
　 while(p1&&p2) 
//p1和p2均非空
　 {
　　 if(p1->expn==p2->expn) 
//指数相等
　　 { 
　　　　 sum=p1->coef+p2->coef; 
//sum 保存两项的系数和 
　　　　 if(sum!=0) 
//系数和不为0
　　　　 {
　　　　　　p1->coef=sum; 
//修改Pa当前结点的系数值为两项系数的和 
　　　　　　p3->next=p1; p3=p1; 
//将修改后的Pa当前结点链接在p3之后，p3指向p1
　　　　　　p1=p1->next; 
//p1指向后一项 
　　　　　　r=p2; p2=p2->next; delete r; // 删除Pb当前结点，p2指向后一项
　　　　 } 
　　　　 else 
//系数和为0
　　　　 {
　　　　　　r=p1; p1=p1->next; delete r; 
// 删除Pa当前结点，p1指向后一项
　　　　　　r=p2; p2=p2->next; delete r; 
// 删除Pb当前结点，p2指向后一项
多项式的相加

48
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
　　　　 } 
　　 } 
　　　else if(p1->expn<p2->expn) 
//Pa当前结点的指数值小
　　　{
　　　　 p3->next=p1; 
//将p1链接在p3之后 
　　　　 p3=p1; 
//p3指向p1 
　　　　 p1=p1->next; 
//p1指向后一项 
　　　} 
　　　else 
//Pb当前结点的指数值小
　　　{
　　　　 p3->next=p2; 
//将p2链接在p3之后 
　　　　 p3=p2; 
//p3指向p2 
　　　　 p2=p2->next; 
//p2指向后一项 
　　　}
　 } 
//while 
　 p3->next=p1?p1:p2; 
//插入非空多项式的剩余段 
　 delete Pb; 
//释放Pb的头结点 
}
【算法分析】
假设两个多项式的项数分别为m 和n，则同算法2.17 一样，该算法的时间复杂度为
O(m + n)，空间复杂度为O(1)。
对于两个一元多项式减法和乘法的运算，都可以利用多项式加法的算法来实现。减法运算
比较简单，只需要先对要减的多项式的每项系数进行取反，再调用加法运算AddPolyn 即可。多
项式的乘法运算可以分解为一系列的加法运算。假设A(x) 和B(x) 为式（2-1）的多项式，则：
M(x) = A(x) × B(x) 
 
= A(x) × [b1xe + b2
2
n
1
ex + … + bnxe ] 
=
1
( )
i
n
e
i
i
b A x x
=∑
 
其中，每一项都是一个一元多项式。
多项式相加的例子说明，对于一些有规律的数学运算，借助链表实现是一种解决问题的 
途径。
案例2.3 ：图书信息管理系统。
【案例分析】
把图书表抽象成一个线性表，每本图书（包括ISBN、书名、定价）作为线性表中的一个元
素。在图书信息管理系统中要求实现查找、插入、删除、修改、排序和计数总计6 个功能，具
体分析如下。
（1）对于查找、插入、删除这3 个功能的算法，本章已分别给出了线性表利用顺序存储结
构和链式存储结构表示时相应的算法描述。
（2）对于修改功能，可以通过调用查找算法，找到满足条件的图书进行修改。
（3）对于排序功能，在没有时间复杂度限制的情况下，可以采用读者熟悉的冒泡排序来完
成；如果图书数目较多，对排序算法的时间效率要求较高，在学完第8 章的内部排序算法后，
可以选取一种较高效的排序算法来实现，如快速排序。
（4）对于计数功能，如果采取顺序存储结构，线性表的长度是它的属性，可以直接通过返回
length 的值实现图书数量的统计功能，时间复杂度是O(1) ；如果采取链式存储结构，则需要通过
从首元结点开始，附设一个计数器进行计数，一直“数”到最后一个结点，时间复杂度是O(n)。

49
第
2
章
 
线
性
表
在实现图书信息管理系统时，具体采取哪种存储结构，可以根据实际情况而定。如果图书
数据较多，需要频繁地进行插入和删除操作，则宜采取链表表示；反之，如果图书数据变化不
大，很少进行插入和删除操作，则宜采取顺序表表示。
此案例中所涉及的算法比较基础，但非常重要，读者可以分别采用顺序表和链表实现此案
例的相应功能，作为本章的实验题目来完成。
2.9  LeetCode算法练习题
为使本节各算法练习题中的算法描述部分所使用的链表存储结构与LeetCode 官方一致，将
本节中单链表的存储结构定义如下：
//- - - - - 单链表的存储结构- - - - - 
typedef struct ListNode 
{
  ElemType val; 
 
 
 
// 结点的数据域
  struct ListNode *next; 
 
 
// 结点的指针域
}LNode, *LinkList;
另外，为了确保每个练习题中算法描述部分给出的代码提交到LeetCode 官网可以通过，与
前面章节算法描述部分的代码不同的是，本节中的代码均采用C 语言源码形式（动态内存分配
采用C 语言的malloc() 函数），后面第3 ～8 章中LeetCode 算法练习题中算法描述部分给出的
代码也如此。
【算法练习题2.1】 LeetCode 26 删除有序数组中的重复项★
【问题描述】
给定一个升序排列的数组，原地删除重复出现的元素，使得每个元素只出现一次，返回删
除后数组的长度。注意：不可以使用额外的数组空间，即算法的空间复杂度为O(1)。
【输入输出示例】
输入：nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
输出：5，nums = [0, 1, 2, 3, 4]
解释：函数应该返回新的数组长度5，并且原数组nums 的前5 个元素被修改为0, 1, 2, 3, 4。
不需要考虑数组中超出新长度的元素。
【问题分析】
本题需要首先判断数组的长度是否为0，如果是，则数组不包含任何元素，返回0 ；否则，
数组至少包含一个元素，数组的第一个元素保持原状即可，从数组下标为 1 的位置开始删除重
复元素。
由于给定的数组nums 是有序的，因此对于任意的i < j，如果nums[i] = nums[j]，则对任意
i ≤k ≤j，必有nums[i] = nums[k] = nums[j]，即相等元素在数组中的下标一定是连续的。根据
数组有序的特点，可以利用双指针的方法遍历数组来删除重复元素。定义两个指针 fast 和 slow，
分别为快指针和慢指针，初始时两个指针均指向数组下标为1 的位置，fast 指针用于遍历数组，
slow 指针用于指向下一个不重复的元素要填入的下标位置。如果nums[fast] ≠nums[fast - 1]，说
明nums[fast] 和前面的元素均不相同，则将nums[fast] 的值复制到nums[slow]，然后将slow 的
值加1，即指向下一个位置。遍历结束之后，从nums[0] 到nums[slow - 1] 的每个元素均不相同，
且包含原数组中的每个不同的元素，因此新的数组长度即为slow，返回slow 即可。具体实现步
骤如图2.24 所示。

50
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
0
0
1
1
1
2
2
3
3
4
slow
0
1
2
3
4
5
6
7
8
9
fast
（a）初始时双指针指向数组下标为1的位置
（b）fast指针向后移动找到非重复元素位置
（c）fast位置的值复制到slow位置，并移动slow指针
（d）遍历数组，返回数组新长度slow=5
slow
fast
0
0
1
1
1
2
2
3
3
4
0
1
2
3
4
5
6
7
8
9
slow
fast
0
1
1
1
1
2
2
3
3
4
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
2
2
3
3
4
slow
0
1
2
3
4
5
6
7
8
9
fast
图2.24  LeetCode 26具体实现步骤
【算法步骤】
① 判断数组长度是否为0，如果是则返回0。
② 定义fast 和slow 指针，初始时二者均指向数组下标为1 的位置。
③ fast 从1 到numsSize − 1 依次遍历数组，循环执行以下操作：如果nums[fast] ≠nums[fast - 1]，
则将 nums[fast] 的值复制到nums[slow]，然后将slow 的值加1。
④ 返回数组的新长度slow。
【算法描述】
int removeDuplicates(int* nums, int numsSize) 
{// 删除升序数组nums 中的重复元素 
  if(numsSize==0) 
 
 
 
// 数组长度为0
     return 0;    
  int fast=1, slow=1; 
 
 
// 初始化快、慢两个指针
  while(fast<numsSize) 
 
 
//fast依次遍历从1到numsSize-1的每个位置
  {
    if(nums[fast]!=nums[fast-1])  
//fast 找到非重复元素的位置
    {
      nums[slow]=nums[fast]; 
 
// 将nums[fast] 的值复制到nums[slow]
      ++slow; 
 
 
 
//slow 的值加1
    }
    ++fast;
  }

51
第
2
章
 
线
性
表
  return slow; 
 
 
 
// 返回数组的新长度
}
【算法分析】
由于需要使用快、慢指针遍历整个输入数组，因此时间复杂度为O(n) ；由于双指针方法删
除升序数组中的重复元素只需复写原数组空间，而不需要额外空间，因此空间复杂度为O(1)。
【算法练习题2.2】LeetCode 61 旋转链表★★
【问题描述】
给定一个链表，旋转链表，将链表每个结点向右移动k 个位置，其中k 为非负数。
【输入输出示例】
输入：head = [1, 2, 3, 4, 5]，k = 2
输出：[4, 5,1, 2, 3]
链表旋转过程如图2.25 所示。
1
旋转1次
旋转2次
2
2
2
3
3
3
4
4
4
5
5
5
1
1
图2.25  链表旋转过程
【问题分析】
记给定链表的长度为n，由于每移动n 次链表会变为原状，因此当向右移动的次数k ≥n
时，链表只需向右移动 k%n 次，旋转后链表的尾结点为原链表的第n - (k%n) 个结点。根据以上
描述，首先将链表尾结点指针域指向首元结点，使给定的链表闭合成环；然后计算旋转后链表
的尾结点的位置，并将环形链表断开，返回旋转后的链表。具体实现步骤如图2.26 所示。
（a）链表初始状态（k=2）
（b）链表闭合成环
（c）在尾结点位置将环形链表断开
（d）旋转后链表
newhead
4
5
1
2
3
head
1
2
3
4
5
∧
∧
∧
1
2
3
4
5
1
2
3
4
5
图2.26  LeetCode 61具体实现步骤
【算法步骤】
① 若链表长度不大于1，或k = 0，可直接返回原链表。
② 统计链表结点个数n，并将指针tail 指向链表尾结点。

52
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
③ 计算链表实际需要向右移动次数movenum。
④ 若k 为n 的整数倍，返回原链表。
⑤ 若k 不是n 的整数倍，则将链表尾结点指针域指向首元结点，使链表闭合成环。
⑥ 确定旋转后链表的尾结点，在环形链表第addnum（n - movenum）个结点位置将链表断开。
⑦ 返回旋转后的链表newhead。
【算法描述】
struct ListNode* rotateRight(struct ListNode* head, int k) 
{ // 将链表的每个结点向右移动k 个位置
  if (k == 0 || head == NULL || head->next == NULL)
     return head;  
 
 
// 如果链表长度不大于1，或k=0，返回原链表
  int n = 1;
  struct ListNode* tail = head;
  while (tail->next != NULL) 
 
// 统计链表结点，tail 指向链表尾部 
  {
    tail = tail->next;
    n++;
  }
  int movenum = k%n; 
 
 
// 链表实际需向右移动次数
  if (movenum == 0)  
 
 
//k 为n 的整数倍，返回原链表
    return head;
  tail->next = head; 
 
 
// 链表闭合成环
  int addnum = n-movenum;  
 
// 计算旋转后链表的尾结点的位置
  while (addnum--)
    tail = tail->next; 
 
 
// 确定旋转后链表的尾结点
  struct ListNode* newhead = tail->next;
  tail->next = NULL; 
 
 
// 环形链表断开
  return newhead; 
 
 
 
// 返回旋转后链表
}
【算法分析】
最坏情况下，需要遍历原链表两次，因此时间复杂度为O(n) ；算法不需要额外空间，因此
空间复杂度为O(1)。
【算法练习题2.3】LeetCode 86 分隔链表★★
【问题描述】
给定一个链表和特定值x，对链表进行分隔，使得所有小于x 的结点都出现在大于或等于x
的结点之前，并保留以x 为界的左右两个区域中结点的初始相对位置。
【输入输出示例】
输入：head = [1, 4, 3, 2, 5, 2]，x = 3
输出：[1, 2, 2, 4, 3, 5]
链表分隔过程如图2.27 所示。
1
1
2
2
2
2
4
4
5
5
3
3
图2.27  链表分隔过程

53
第
2
章
 
线
性
表
【问题分析】
本题可以另外设置small 和large 两个带头结点的链表，分别用来存储原链表中小于x 的结
点和大于或等于x 的结点。首先遍历原链表，判断当前结点的值是否小于x，若是，则使用后插
法将其插入链表small，否则插入链表large。由于small 和large 两个链表中的结点复用了原链表
的结点，而链表large 尾结点的指针域可能指向一个小于x 的结点，因此遍历原链表之后需要将
链表large 尾结点的指针域置空。最后将链表small 尾结点的指针域指向链表large 的首元结点，
返回分隔后的链表即可。具体实现步骤如图2.28 所示。
（a）链表初始状态（x=3）
（b）原链表分隔为两个链表
（c）分隔并重新拼接的新链表
head
1
4
3
2
5
2
∧
newhead
1
2
2
4
3
5
∧
∧
2
1
2
small
small
∧
5
4
3
large
large
图2.28  LeetCode 86具体实现步骤
【算法步骤】
① 定义small 和large 两个指针，分别指向新生成的两个链表的头结点。
② 指针pa、pb 和pc 初始化，pa 指向原链表的首元结点，pb 和pc 分别指向small 和large
的头结点。
③ 遍历原链表，并循环执行以下操作：
l 若pa 所指结点的值小于x，则将其插入链表small，并将pb 指向新插入结点；
l 若pa 所指结点的值大于或等于x，则将其插入链表large，并将pc 指向新插入结点；
l pa 指向下一个结点。
④ 将pc 的指针域置空。
⑤ 将pb 的指针域指向large 链表的首元结点。
⑥ 将newhead 指向链表small 的首元结点，并返回分隔后的链表newhead。
【算法描述】
struct ListNode* partition(struct ListNode* head, int x)
{// 以特定值x 为界对链表进行分隔
  struct ListNode* small=(struct ListNode*)malloc(sizeof(struct ListNode));
  struct ListNode*large=(struct ListNode*)malloc(sizeof(struct ListNode));
  struct ListNode*pa=head;
  struct ListNode*pb=small;
  struct ListNode*pc=large;   
  while (pa != NULL)
  {
    if (pa->val < x) 
 
 
// 当前结点的值小于x，将其插入small

54
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
    {
      pb->next = pa;
      pb = pb->next;
    }
    else 
 
 
 
 
// 当前结点插入large
    {
      pc->next = pa;
      pc = pc->next;
    }
    pa = pa->next;
  }
  pc->next = NULL;
  pb->next = large->next;  
 
// 链表拼接
  struct ListNode* newhead = small->next;
  return newhead;
}
【算法分析】
由于需要对链表进行一次遍历，因此时间复杂度为O(n) ；算法不需要额外空间，因此空间
复杂度为O(1)。
【算法练习题2.4】LeetCode 142 环形链表 II ★★ 
【问题描述】
给定一个链表，判断链表中是否有环。如果有环，则返回链表开始入环的第一个结点，否
则返回NULL。
【输入输出示例】
输入：head = [3, 2, 0, -4]，pos = 1。
为了表示给定链表中的环，使用整数 pos 来表示链表尾结
节链接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则该
链表中没有环。注意：pos 不作为参数进行传递，仅用于标识链
表的实际情况。该链表输入如图2.29 所示。
输出：索引为 1 的链表结点
解释：链表中有一个环，其尾部链接到第二个结点。
【问题分析】
本题可以利用双指针的方法判断链表中是否有环。首先定义两个指针 fast 和 slow，分别
为快指针和慢指针，初始时两个指针均指向链表首元结点。之后，fast 每次向后移动两个位
置， slow 每次向后移动一个位置，如果链表中存在环，则fast 最终将与slow 在环中相遇。如
图2.30 所示，设置链表中环外部分的长度为a，slow 入环后，又移动长度为b 的距离与fast 相
遇，此时，fast 已经绕环移动n 圈。假设fast 移动的总距离为S，则S = a + n(b + c) + b。其中，c
为环内剩余长度。由于任意时刻，fast 移动的距离为slow 的2 倍，因此S = 2(a + b)。推导可得 
a = c + (n - 1)(b + c)，即链表头与入环点间的距离恰好等于
相遇点与入环点间的距离加上n - 1 圈环长。根据上述关系，
在fast 和slow 相遇后设置一个额外指针p，初始时指向链
表首元结点，随后，p 和slow 每次向后移动一个位置。最
终，p 和slow 在入环点相遇，返回p即可。返回链表开始
入环的第一个结点5 的具体实现步骤如图2.31 所示。
3
2
0
-4
图2.29  链表输入示例
a
b
c
图2.30  链表各部分长度

55
第
2
章
 
线
性
表
（a）初始时快、慢指针位置（pos=3）
（b）快、慢指针移动一次
（c）环内相遇
（d）设置指针p指向首元结点
（e）返回入环结点
head
fast
slow
4
3
7
2
1
5
6
head
fast
slow
4
3
7
2
1
5
6
head
fast
slow
4
3
7
2
1
5
6
slow
相遇结点
fast
head
4
3
7
2
1
5
6
slow
p
相遇结点
head
4
3
7
2
1
5
6
slow
p
图2.31  LeetCode 142具体实现步骤
【算法步骤】
① 定义指针fast 和slow，初始时二者均指向链表首元结点。
② 当fast 所指结点为空时，返回NULL，否则循环执行以下操作。

56
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
l 如果fast 的后继结点为空，返回NULL。
l slow 每次向后移动一个位置，fast 每次向后移动两个位置。
l 如果fast 和slow 相遇，定义p 指针，初始时指向链表首元结点，循环执行以下操作：
p 和slow 每次均向后移动一个位置，最终在入环的第一个结点处相遇，返回入环的第一个结 
点p。
【算法描述】
struct ListNode* detectCycle(struct ListNode* head) 
{// 判断链表中是否有环，若有，则返回入环的第一个结点
  struct ListNode *slow = head, *fast = head;      // 初始化fast 和slow 两个指针
  while (fast != NULL) 
  { 
    if (fast->next == NULL) 
      return NULL;                              // 链表中没有环，返回NULL 
    slow = slow->next;                           //slow 向后移动一个位置
    fast = fast->next->next;                     //fast 向后移动两个位置
    if (fast == slow)                            //fast 和slow 相遇 
    {
       struct ListNode* p = head;               // 指针p 指向链表首元结点
       while (p != slow) 
       {
         p = p->next;
         slow = slow->next;
       }
       return p;                               // 返回入环的第一个结点
    }
  }
  return NULL;
}
【算法分析】
在最初判断快、慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度，随后寻
找入环点时，走过的距离也不会超过链表的总长度，因此时间复杂度为O(n) ；算法不需要额外
空间，空间复杂度为O(1)。
【算法练习题2.5】LeetCode 25 k 个一组翻转链表★★★
【问题描述】
给定一个链表，每k 个结点一组进行翻转，返回修改后的链表。
【输入输出示例】
输入：head = [1, 2, 3, 4, 5]，k = 2
输出：[2, 1, 4, 3, 5]
翻转过程如图2.32 所示。
1
1
2
2
4
4
5
5
3
3
图2.32  链表翻转过程

57
第
2
章
 
线
性
表
【问题分析】
记给定链表的长度为n，首先设置一个带头结点的链表s 和指针cur，并将cur 指向s 的头
结点；然后将链表结点按照k 个一组进行分组，可以得到有n/k 个分组需要进行翻转；对每个分
组进行翻转，并使用后插法将翻转后的各个分组插入s ；然后将cur 指向翻转部分链表的尾结点
位置，为下一组翻转做准备；将不需要进行翻转的部分直接插入翻转部分链表尾部；最后返回
翻转后的链表。具体实现步骤如图2.33 所示。
（a）链表初始状态（k=2）
（b）翻转第1个分组并插入
（c）翻转第2个分组并插入
（d）翻转后链表
head
1
2
3
4
5
s
∧
newhead
2
1
4
3
5
∧
3
4
5
∧
5
∧
2
1
∧
4
3
∧
s
2
1
s
cur
cur
cur
图2.33  LeetCode 25具体实现步骤
【算法步骤】
① 定义s 指针，指向新生成的链表的头结点。
② 定义cur 指针，将cur 指向s。
③ 定义slow、fast 和 prev 指针，并将slow 指向原链表首元结点，fast 和prev 置空。
④ 统计链表结点个数n，并计算需要进行翻转的组数n/k 。
⑤ 针对需要翻转的各组结点循环执行以下操作：
l slow 指向当前结点，fast 指向slow 的后继结点，然后将slow 的指针域指向前驱结点
prev，实现组内结点的翻转；
l 使用后插法将翻转后的各组结点插入s ；
l cur 指向翻转部分链表尾部。
⑥ 将不需要进行翻转的部分直接插入到链表尾部，即cur 的指针域指向此部分的第一个结点。
⑦ 将newhead 指向链表s 的首元结点，并返回翻转后的链表newhead。
【算法描述】
struct ListNode* reverseKGroup(struct ListNode* head, int k)
{//k 个一组对链表进行翻转
    int x=k;
    int n=0;                                       
    struct ListNode* s = (struct ListNode*)malloc(sizeof(struct ListNode)); 
    struct ListNode* cur=s;                // 定义cur,指向S
    struct ListNode* slow=head;

58
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
    struct ListNode* fast=NULL;
    struct ListNode* prev=NULL;
    while(slow)                            // 统计链表结点
    {
        n++;
        slow=slow->next;
    }
    slow=head;
    n/=k;                                  // 需进行翻转的组数
    for(int i=0;i<n;i++)
    {
        while(x)
        {                                  //k 个一组进行翻转
            fast=slow->next;
            slow->next=prev;
            prev=slow;
            slow=fast;
            x--;
        }
        cur->next=prev;
        while(cur->next)                   //cur 向前移动，为下一组翻转做准备
            cur=cur->next;        
        prev=NULL;                         //prev置空，保证下一次cur向前走不会死循环
        x=k;
    }
    cur->next=slow;                        // 链接没有被翻转的部分
    struct ListNode* newhead = s->next;
    return newhead;
}
【算法分析】
cur 指针会在O(
n
k



) 个结点上停留，每次停留需要进行一次时间复杂度为O(k) 的翻转操
作，因此时间复杂度为O(n) ；算法不需要额外空间，因此空间复杂度为O(1)。
2.10　小结
线性表是整个数据结构课程的重要基础，本章主要内容如下。
（1）线性表的逻辑结构特性是指数据元素之间存在着线性关系，在计算机中表示这种关系
的两类不同的存储结构是顺序存储结构（顺序表）和链式存储结构（链表）。
（2）对于顺序表，元素存储的相邻位置反映出其逻辑上的线性关系，可借助数组来表示。
给定数组的下标，便可以存取相应的元素，可称为随机存取结构。而对于链表，其是依靠指针
来反映其线性逻辑关系的，链表结点的存取都要从头指针开始，顺链而行，所以不属于随机存
取结构，可称之为顺序存取结构。不同的特点使得顺序表和链表有不同的适用情况，表2.2 分别
从空间、时间和适用情况3 个方面对二者进行了比较。

59
第
2
章
 
线
性
表
表2.2　顺序表和链表的比较
比较项目
存储结构
顺序表
链表
空间
存储空间
预先分配，会出现空间闲置或溢出现象
动态分配，不会出现存储空间闲置
或溢出现象
存储密度
不用为表示结点间的逻辑关系而增加额外
的存储开销，存储密度等于1
需要借助指针来体现元素间的逻辑
关系，存储密度小于1
时间
存取元素
随机存取，按位置访问元素的时间复杂度
为O(1)
顺序存取，按位置访问元素时间复
杂度为O(n)
插入、删除
平均移动约表中一半元素，时间复杂度为
O(n)
不需移动元素，确定插入、删除位
置后，时间复杂度为O(1)
适用情况
① 表长变化不大，且能事先确定变化的 
范围
② 很少进行插入或删除操作，经常按元素
位置序号访问数据元素
① 长度变化较大
② 频繁进行插入或删除操作
（3）对于链表，除了常用的单链表外，在本章还讨论了两种不同形式的链表，即循环链表
和双向链表，它们有不同的应用场合。表2.3 对三者的几项有差别的基本操作进行了比较。
表2.3　单链表、循环链表和双向链表的比较
链表名称
操作名称
查找首元结点
查找表尾结点
查找结点*p的前驱结点
带头结点的 
单链表L
L->next
时间复杂度O(1)
从L->next 依次向后遍历
时间复杂度O(n)
通过p->next 无法找到其前驱
带头结点仅设头指
针L 的循环单链表
L->next
时间复杂度O(1)
从L->next 依次向后遍历
时间复杂度O(n)
通过p->next 可以找到其前驱
时间复杂度O(n)
带头结点仅设尾指
针R 的循环单链表
R->nextt->next
时间复杂度O(1)
R
时间复杂度O(1)
通过p->next 可以找到其前驱
时间复杂度O(n)
带头结点的双向循
环链表L
L->next
时间复杂度O(1)
L->prior
时间复杂度O(1)
p->prior
时间复杂度O(1)
学习完本章后，读者应熟练掌握顺序表和链表的查找、插入和删除算法，链表的创建算法，
并能够设计出线性表应用的常用算法，比如线性表的合并等；能够从时间和空间复杂度的角度
比较两种存储结构的不同特点及其适用场合，明确它们各自的优缺点。
习题
1．选择题
（1）顺序表中第一个元素的存储地址是100，每个元素的长度为2，则第5 个元素的地址是
（　　）。
A．110 
 
B．108
C．100 
 
D．120

60
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
（2）在含n 个结点的顺序表中，算法的时间复杂度是O(1) 的操作是（　　）。
A．访问第i 个结点（1 ≤i ≤n）和求第i 个结点的直接前驱（2 ≤i ≤n） 
B．在第i 个结点后插入一个新结点（1 ≤i ≤n）
C．删除第i 个结点（1 ≤i ≤n）
D．将n 个结点从小到大排序
（3）在一个有127 个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动的
元素个数为（　　）。
A．8 
B．63.5 
C．63 
D．7
（4）链接存储的存储结构所占存储空间（　　）。
A．分为两部分，一部分存放结点值，另一部分存放表示结点间关系的指针
B．只有一部分，存放结点值
C．只有一部分，存储表示结点间关系的指针
D．分为两部分，一部分存放结点值，另一部分存放结点所占单元数
（5）线性表若采用链式存储结构，要求内存中可用存储单元的地址（　　）。
A．必须是连续的 
 
B．部分地址必须是连续的
C．一定是不连续的  
D．连续或不连续都可以
（6）线性表Ｌ在（　　）情况下适用于使用链式结构实现。
A．需经常修改Ｌ中的结点值 
B．需不断对Ｌ进行删除、插入 
C．Ｌ中含有大量的结点 
D．Ｌ中结点结构复杂
（7）单链表的存储密度（　　）。
A．大于1 
B．等于1 
C．小于1 
D．不能确定
（8）将两个各有n 个元素的有序表归并成一个有序表，其最少的比较次数是（　　）。
A．n 
B．2n−1 
C．2n 
D．n−1
（9）在一个长度为n 的顺序表中，在第i 个元素（1 ≤i ≤n + 1）之前插入一个新元素时需
向后移动（　　）个元素。
A．n − i 
B．n − i + 1 
C．n − i − 1 
D．i
（10）线性表L = (a1, a2, …, an)，下列陈述正确的是（　　）。
A．每个元素都有一个直接前驱和一个直接后继
B．线性表中至少有一个元素
C．表中诸元素的排列必须是由小到大或由大到小的
D． 除第一个和最后一个元素外，其余每个元素都有一个且仅有一个直接前驱和直接
后继
（11）创建一个包括n 个结点的有序单链表的时间复杂度是（　　）。
A．O(1) 
B．O(n) 
C．O(n2) 
D．O(nlog2n)
（12）以下陈述错误的是（　　）。
A． 求表长、定位这两种运算在采用顺序存储结构时实现的效率不比采用链式存储结
构时实现的效率低
B．顺序存储的线性表可以随机存取
C．由于顺序存储要求连续的存储区域，因此在存储管理上不够灵活
D．线性表的链式存储结构优于顺序存储结构

61
第
2
章
 
线
性
表
（13）在单链表中，要将s 所指结点插入p 所指结点之后，其语句应为（　　）。
A．s->next = p + 1; p->next = s;
B．(*p).next = s; (*s).next = (*p).next;
C．s->next = p->next; p->next = s->next;
D．s->next = p->next; p->next = s;　　　　
（14）在双向链表存储结构中，删除p 所指结点时修改指针的操作为（　　）。
A．p->next->prior = p->prior; p->prior->next = p->next;
B．p->next = p->next->next; p->next->prior = p;
C．p->prior->next = p; p->prior = p->prior->prior;
D．p->prior = p->next->next; p->next = p->prior->prior;
（15）在双向循环链表中，在p 指针所指的结点后插入q 所指向的新结点，其修改指针的操
作是（　　）。
A．p->next = q; q->prior = p; p->next->prior = q; q->next = q;
B．p->next = q; p->next->prior = q; q->prior=p; q->next = p->next;
C．q->prior = p; q->next = p->next; p->next->prior = q; p->next = q;
D．q->prior = p; q->next = p->next; p->next = q; p->next->prior = q;
2．算法设计题
（1）将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链
表的存储空间，不另外占用其他的存储空间。表中不允许有重复的数据。
（2）将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两
个链表的存储空间，不另外占用其他的存储空间。表中允许有重复的数据。
（3）已知两个链表A 和B 分别表示两个集合，其元素递增排列。请设计一个算法，用于求
出A 与B 的交集，并将结果存放在A 链表中。
（4）已知两个链表A 和B 分别表示两个集合，其元素递增排列。请设计算法求出两个集合
A 和B 的差集（仅由在A 中出现而不在B 中出现的元素所构成的集合），并将结果以同样的形
式存储，同时返回该集合的元素个数。
（5）设计算法将一个带头结点的单链表A 分解为两个具有相同结构的链表B 和C，其中B
表的结点为A 表中值小于0 的结点，而C 表的结点为A 表中值大于0 的结点（链表A 中的元
素为非零整数，要求B、C 表利用A 表的结点）。
（6）设计一个算法，通过一趟遍历确定长度为n 的单链表中值最大的结点。
（7）设计一个算法，将链表中所有结点的链接方向“原地”逆转，即要求仅利用原表的存
储空间，换句话说，要求算法的空间复杂度为O(1)。
（8）设计一个算法，删除递增有序链表中值大于mink 且小于maxk 的所有元素（mink 和
maxk 是给定的两个参数，其值可以和表中的元素相同，也可以不同）。
（9）已知p 指向双向循环链表中的一个结点，其结点结构为data、prior、next 这3 个域，
设计算法change(p)，交换p 所指向的结点及其前驱结点的顺序。
（10）已知长度为n 的线性表A 采用顺序存储结构，请设计一个时间复杂度为O(n)、空间
复杂度为O(1) 的算法，该算法可删除线性表中所有值为item 的数据元素。