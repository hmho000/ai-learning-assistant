第 章

线 性 表 ④ 当指针pa 和pb 均未到达相应表尾时，则依次比较pa 和pb 所指向的元素值，从LA 或 LB 中“摘取”元素值较小的结点插入LC 的最后。
⑤ 如果pb 已到达LB 的表尾，依次将LA 的剩余元素插入LC 的最后。
⑥ 如果pa 已到达LA 的表尾，依次将LB 的剩余元素插入LC 的最后。
【算法描述】
void MergeList_Sq(SqList LA,SqList LB,SqList &LC)
{// 已知顺序有序表LA和LB的元素按值非递减排列
 // 归并LA 和LB 得到新的顺序有序表LC，LC的元素也按值非递减排列
  LC.length=LA.length+LB.length;
// 新表长度为待合并两表的长度之和
  LC.elem=new ElemType[LC.length];
// 为合并后的新表分配一个数组空间
  pc=LC.elem;
//指针pc指向新表的第一个元素
  pa=LA.elem; pb=LB.elem;
//指针pa和pb的初值分别指向两个表的第一个元素
  pa_last=LA.elem+LA.length-1;
// 指针pa_last 指向LA的最后一个元素
  pb_last=LB.elem+LB.length-1;
// 指针pb_last 指向LB的最后一个元素
  while((pa<=pa_last)&&(pb<=pb_last)) // 未达到LA和LB的表尾
  {
   if(*pa<=*pb) *pc++=*pa++;
// 依次摘取两表中值较小的结点插入LC的最后
   else *pc++=*pb++;
  }
  while(pa<=pa_last) *pc++=*pa++;
//已到达LB表尾，依次将LA的剩余元素插入LC的最后
  while(pb<=pb_last) *pc++=*pb++;
//已到达LA表尾，依次将LB的剩余元素插入LC的最后
}
【算法分析】
若对算法2.16 中第一个循环语句的循环体进行如下修改：分出元素比较的第三种情况，当
*pa ==*pb 时，只将两者之一插入LC，则该算法完成的操作和算法2.15 相同，但时间复杂度却
不同。在算法2.16 中，由于LA 和LB 中元素依值非递减，则对LB 中的每个 元素，不需要在LA 中从表头至表尾进行全程搜索。如果两个表长分别记为m 和n，则算法2.16 循环最多执行的总次数为m + n。所以算法的时间复杂度为 O(m + n)。
此算法在归并时，需要开辟新的辅助空间，所以空间复杂度也为O(m + n)， 空间复杂度较高。利用链表来实现上述归并时，不需要开辟新的存储空间，可 以使空间复杂度达到最低。
2．链式有序表的合并 假设头指针为LA 和LB 的单链表分别为线性表LA 和LB 的存储结构，现要归并LA 和LB 得到单链表LC。因为链表结点之间的关系是通过指针指向建立起来的，所以用链表进行合并不 需要另外开辟存储空间，可以直接利用原来两个表的存储空间，合并过程中只需把LA 和LB 两 个表中的结点重新进行链接即可。
按照例2.2 给出的合并思想，需设立3 个指针pa、pb 和pc，其中pa 和pb 分别指向LA 和 LB 中当前待比较插入的结点，而pc 指向LC 中当前最后一个结点（LC 的表头结点设为LA 的 表头结点）。指针的初值为：pa 和pb 分别指向LA 和LB 表中的第一个结点，pc 指向空表LC 中 的头结点。同算法2.16 一样，通过比较指针pa 和pb 所指向的元素的值，依次从LA 或LB 中 摘取元素值较小的结点插入到LC 的最后，当其中一个表变空时，只要将另一个表的剩余段链接 在pc 所指结点之后即可。
顺序有序表的 合并

数 据 结 构

（ 第 版 ）

算法2.17 链式有序表的合并 【算法步骤】
① 指针pa 和pb 初始化，分别指向LA 和LB 的第一个结点。
② LC 的结点取值为LA 的头结点。
③ 指针pc 初始化，指向LC 的头结点。
④ 当指针pa 和pb 均未到达相应表尾时，则依次比较pa 和pb 所指向的 元素值，从LA 或LB 中摘取元素值较小的结点插入LC 的最后。
⑤ 将非空表的剩余段插入pc 所指结点之后。
⑥ 释放LB 的头结点。
【算法描述】
void MergeList_L(LinkList &LA,LinkList &LB,LinkList &LC)
{// 已知单链表LA和LB的元素按值非递减排列
 // 归并LA 和LB得到新的单链表LC，LC的元素也按值非递减排列
  pa=LA->next;pb=LB->next;

//pa 和pb的初值分别指向两个表的第一个结点
  LC=LA;

// 用LA的头结点作为LC的头结点
  pc=LC;

//pc的初值指向LC的头结点
  while(pa&&pb)

  {//LA 和LB均未到达表尾，依次“摘取”两表中值较小的结点插入到LC的最后
   if(pa->data<=pb->data)

// 摘取pa所指结点
   {
     pc->next=pa;

// 将pa所指结点链接到pc所指结点之后
     pc=pa;

//pc 指向pa
     pa=pa->next;

//pa 指向下一结点
   }
   else

// 摘取pb所指结点
   {
     pc->next=pb;

// 将pb所指结点链接到pc所指结点之后
     pc=pb;

//pc 指向pb
     pb=pb->next;

//pb 指向下一结点
   }
  }

//while
   pc->next=pa?pa:pb;

// 将非空表的剩余段插入到pc所指结点之后
   delete LB;

// 释放LB的头结点
}
【算法分析】
可以看出，算法2.17 的时间复杂度和算法2.16 相同，但空间复杂度不同。在归并两个链 表为一个链表时，不需要另建新表的结点空间，而只需将原来两个链表中结点之间的关系解除， 重新按元素值非递减的关系将所有结点链接成一个链表即可，所以空间复杂度为O(1)。
2.8 案例分析与实现 在2.2 节我们通过3 个典型案例引入了线性表这种数据结构，本节结合线性表的基本操作 对这3 个案例进行进一步的分析，然后给出案例中有关算法的具体实现。
链式有序表的 合并