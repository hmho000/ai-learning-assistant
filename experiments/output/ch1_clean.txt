第 章

绪 论 构”的研究过程中，将遇到大量的算法问题，这些算法联系着数据在计算过程中的组织方式， 为了描述如何实现某种操作，常常需要设计算法，因而算法是研究数据结构的重要途径。
1.4.1 算法的定义及特性 算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列。
沃斯教授指出：程序= 数据结构+ 算法。这说明数据结构和算法是程序的两大要素，二者相 辅相成，缺一不可。程序设计的本质是为要处理的问题选择好的数据结构，同时在此结构上施加 一种好的算法。算法和数据结构不可分割，共同构成了程序设计世界的基石。如果把程序设计比 作建造房子的话，数据结构可以看作建筑工程中的建筑设计图，算法可以看作施工流程图。
一个算法必须满足以下5 个重要特性。
（1）输入。一个算法有0 个或多个输入。对绝大多数算法来说，输入参数都是必要的，当 用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。
对于简单的算法，数据也可以直接在程序中给定，如打印“hello world”，这时不需要任何输入 参数，因此算法的输入可以是0 个。
（2）输出。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出 的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。
（3）确定性。对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义 性，使算法的执行者或阅读者都能明确其含义及如何执行。
（4）有穷性。一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。
（5）可行性。算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现， 即算法描述中的每条指令都是可执行的。
1.4.2 评价算法优劣的基本标准 同一个现实问题，可以有多个解决问题的算法，不同的算法有各自的优缺点，采用哪种算 法呢？算法评价就帮助我们来解决这一问题。一个算法的优劣应该从以下几方面来评价。
（1）正确性。在合理的数据输入下，能够在有限的运行时间内得到正确的结果。
（2）可读性。一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。
可读性强的算法有助于人们对算法的理解，而难懂的算法容易隐藏错误，且难于调试和修改。
（3）健壮性。当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而 不会产生一些莫名其妙的输出结果。
（4）高效性。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高， 可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。
时间复杂度和空间复杂度是衡量算法的两个主要指标。
追求程序正确性、可读性、健壮性、高效性的道路是永无止境的，随着技术的不断进步和 应用场景的不断变化，我们需要不断学习和探索新的方法以适应新的环境。同时，需要关注程 序设计的伦理和社会责任，尽可能避免对隐私和安全造成的潜在威胁。
1.4.3 算法的时间复杂度 算法效率分析的目的是看算法实际是否可行，并在同一问题存在多个算法时，可进行时间 和空间性能上的比较，权衡需求，以便从中挑选出较优算法。

数 据 结 构

（ 第 版 ）

衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。事后统计法需要先将算 法实现，然后测算其时间和空间开销。这种方法的缺陷很显然，一是必须把算法转换成可执行 的程序，二是时空开销的测算结果依赖于计算机的软硬件等环境因素，这容易掩盖算法本身的 优劣。所以我们通常采用事前分析估算法，通过计算算法的渐近复杂度来衡量算法的效率。
1．问题规模和语句频度 不考虑计算机的软硬件等环境因素，影响算法时间代价的最主要因素是问题规模。问题 规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n 表示。问题规模 n 对不同的问题含义不同，例如，在排序运算中n 为参加排序的记录数，在矩阵运算中n 为 矩阵的阶数，在多项式运算中n 为多项式的项数，在集合运算中n 为集合中元素的个数，在 树的有关运算中n 为树的结点个数，在图的有关运算中n 为图的顶点数或边数。显然，n 越 大算法的执行时间越长。
一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条 语句的重复执行次数和执行一次所需时间的乘积。
一条语句的重复执行次数称作语句频度（Frequency Count）。
由于语句的执行要由源程序经编译程序翻译成目标代码，目标代码经装配再执行，因此语 句执行一次实际所需的具体时间是与机器的软、硬件环境（如机器速度、编译程序质量等）密 切相关的。所以，所谓的算法分析并非精确统计算法实际执行所需时间，而是针对算法中语句 的执行次数做出估计，从中得到算法执行时间的信息。
设每条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有 语句频度之和来度量。
【例1.4】 求两个n 阶矩阵的乘积算法。
for(i=1;i<=n;i++)

// 频度为n+1
  for(j=1;j<=n;j++)

// 频度为n*(n+1)
  {
    c[i][j]=0;

// 频度为n
    for(k=1;k<=n;k++)

// 频度为n
2 * (n+1)
    c[i][j]=c[i][j]+a[i][k]*b[k][j];

// 频度为n
  }
该算法中所有语句频度之和，是矩阵阶数n 的函数，用f(n) 表示之。换句话说，上例算法 的执行时间与f(n) 成正比。
f(n)=2n3+3n2+2n+1 2．算法的时间复杂度定义 对于例1.4 这种较简单的算法，可以直接计算出算法中所有语句的频度；但对于稍微复杂 一些的算法，计算所有语句的频度则通常是比较困难的，即便能够计算出，也可能是个非常复 杂的函数。因此，为了客观地反映一个算法的执行时间，可以只用算法中的“基本语句”的执 行次数来度量算法的工作量。所谓“基本语句”指的是算法中重复执行次数和算法的执行时间 成正比的语句，它对算法运行时间的贡献最大。通常，算法的执行时间是随问题规模增长而增 长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。这种情况下，我们只需要考 虑当问题规模充分大时，算法中基本语句的执行次数在渐近意义下的阶。如例1.4 中矩阵的乘积 算法，当n 趋向无穷大时，显然有