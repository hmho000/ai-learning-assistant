早期的计算机主要用于数值计算，而现在的计算机主要用于非数值计算，包括对字符、
表格和图像等具有一定结构的数据进行处理。这些数据内容存在着某种联系，只有分清楚
数据的内在联系，合理地组织数据，才能对它们进行有效的处理，设计出高效的算法。如
何合理地组织数据、高效地处理数据，这就是“数据结构”主要研究的问题。本章简要介
绍有关数据结构的基本概念和算法分析方法。
1.1　数据结构的研究内容
计算机用于数值计算时，一般要经过如下几个步骤：首先从具体问题中抽象出数学模型，然
后设计一个用于此数学模型的算法，最后编写程序，进行测试、调试，直到解决问题。在此过程
中寻求数学模型的实质是分析问题，从中提取操作的对象，并找出这些操作对象之间的关系，然
后用数学语言加以描述，即建立相应的数学方程。例如，用计算机进行全球天气预报时，就需要
求解一组球面坐标系下的二阶椭圆偏微分方程；预测人口增长时，需要求解常微分方程。求解这
些数学方程的算法属于计算数学研究的范畴，如高斯消元法、差分法、有限元法等算法。但现实
中，更多的实际问题属于非数值计算问题，无法用数学方程来表示。数据结构主要研究非数值计
算问题，非数值计算问题无法用数学方程建立数学模型，下面通过三个实例加以说明。
【例1.1】　学生学籍管理系统。
高等院校教务处使用计算机对全校的学生学籍进行统一管理。学生的基本信息，包括学生
的学号、姓名、性别、籍贯、专业等，如表1.1 所示。每个学生的基本情况按照不同的顺序号，
依次存放在“学生基本信息表”中，教务处可以根据需要在这张表中进行查找。每个学生的基
本信息记录按顺序号排列，形成了学生基本信息记录的线性序列，呈线性关系。
表1.1　学生基本信息表
学号
姓名
性别
籍贯
专业
060214201
杨阳
男
安徽
计算机科学与技术
060214202
薛林
男
福建
计算机科学与技术
060214215
王诗萌
女
吉林
计算机科学与技术
060214216
冯子晗
女
山东
计算机科学与技术
绪论
第1章

2
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
诸如此类的线性表结构还有图书馆的书目管理系统、库存管理系统等。在这类问题中，计算机
处理的对象是各种表，元素之间存在简单一对一的线性关系，因此这类问题的数学模型就是各种线
性表，施加于对象上的操作有查找、插入和删除等。这类数学模型称为“线性”的数据结构。
【例1.2】　人机对弈问题。
计算机之所以能和人对弈是因为已经将对弈的策略在计算机中存储好。由于对弈的过程是
在一定规则下随机进行的，所以，为使计算机能灵活对弈，就必须把对弈过程中所有可能发生
的情况及相应的对策都加以考虑。以简单的井字棋为例，初始状态是一个空的棋盘格局。对弈
开始后，每下一步棋，则构成一个新的棋盘格局，且相对于上一个棋盘格局的可能选择可以有
多种形式，因而整个对弈过程就如同图1.1 所示的“一棵倒长的树”。在这棵“树”中，从初始
状态（根）到某一最终格局（叶子）的一条路径，就是一次具体的对弈过程。
人机对弈问题的数学模型就是用树结构表示棋盘和棋子等，算法是博弈的规则和策略。诸
如此类的树结构还有计算机的文件系统、一个单位的组织机构等。在这类问题中，计算机处理
的对象是树结构，元素之间存在一对多的层次关系，施加于对象上的操作有查找、插入和删除
等。这类数学模型称为“树”的数据结构。
【例1.3】　最短路径问题。
从城市A 到城市B 有多条线路，但每条线路所需的交通费不同，那么，如何选择一条线路，
使得从城市A 到城市B 所需的交通费最少呢？解决的方法是，把这类问题抽象为图的最短路径
问题。如图1.2 所示，图中的顶点代表城市，有向边代表两个城市之间的通路，边上的权值代表
两个城市之间的交通费。求解A 到B 所需的最少交通费，就是要在有向图中A 点（源点）到达
B 点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。
                            
 　　　　　　　　 图1.1　井字棋的对弈树　　　　　　　　　　　 　　　                         图1.2　最短路径问题

3
第
1
章
 
绪
论
最短路径问题的数学模型就是图结构，算法是求解两点之间的最短路径。诸如此类的图结
构还有网络工程图和网络通信图等。在这类问题中，元素之间存在多对多的网状关系，施加于
对象上的操作依然有查找、插入和删除等。这类数学模型称为“图”的数据结构。
从上面3 个实例可以看出，非数值计算问题的数学模型不再是数学方程，而是诸如线性表、
树和图的数据结构。因此，简单地说，数据结构是一门研究非数值计算程序设计中的操作对象，
以及这些对象之间的关系和操作的学科。
20 世纪60 年代初期，“数据结构”有关的内容散见于操作系统、编译原理等课程中。1968
年，“数据结构”作为一门独立的课程被列入美国一些大学计算机科学系的教学计划。同年，著
名计算机科学家唐纳德·克努特（D.E.Knuth）教授发表了《计算机程序设计艺术》第一卷《基
本算法》。这是第一本较系统地阐述“数据结构”基本内容的著作。之后，随着大型程序和大规
模文件系统的出现，结构化程序设计成为程序设计方法学的主要研究方向，人们普遍认为程序
设计的实质就是为所处理的问题选择一种好的数据结构，并在此结构基础上施加一种好的算法，
图灵奖获得者，著名的瑞士计算机科学家沃斯（Wirth）教授的《算法+ 数据结构= 程序》正是
这种观点的集中体现。
目前，数据结构在计算机科学中是一门综合性的专业基础课。数据结构的研究不仅涉及计
算机硬件（特别是编码理论、存储装置和存取方法等）的研究范围，而且和计算机软件的研究
有着密切的关系，无论是编译程序还是操作系统都涉及数据元素在存储器中的分配问题。在研
究信息检索时也必须考虑如何组织数据，以使查找和存取数据元素更为方便。因此，可以认为，
数据结构是介于数学、计算机硬件和软件三者之间的一门核心课程。
有关“数据结构”的研究仍不断发展，一方面，面向各专门领域中特殊问题的数据结构正
在研究和发展；另一方面，从抽象数据类型的观点来讨论数据结构，已成为一种新的趋势，越
来越被人们所重视。
1.2　数据结构的基本概念和术语
下列概念和术语将在后文中多次出现，本节先对这些概念和术语给出确定的含义。
1.2.1　数据、数据元素、数据项和数据对象
数据（Data）是信息的载体，是客观事物的符号表示，是所有能输入计算机中并被计算机程
序处理的符号的总称。如数学计算中用到的整数和实数等数值类型，文本编辑中用到的字符串，
多媒体程序处理的图形、图像、声音及动画等非数值类型，它们通过特殊编码定义后的数据。
数据元素（Data Element）是数据的基本单位，在计算机中通常作为一个整体进行考虑和处
理。在有些情况下，数据元素也称为元素、记录、结点等。数据元素用于完整地描述一个对象，
如前一节示例中的一名学生记录，树中棋盘的一个格局（状态），以及图中的一个顶点等。
数据项（Data Item）是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学
生基本信息表中的学号、姓名、性别等都是数据项。
数据对象（Data Object）是性质相同的数据元素的集合，是数据的一个子集。例如：整数
数据对象是集合N = {0, ±1, ±2, …}，字母字符数据对象是集合C = {‘A’, ‘B’, … ,‘Z’, ‘a’, ‘b’, …, ‘z’}，
学生基本信息表也可以是一个数据对象。由此可以看出，不论数据元素集合是无限集（如整数
集），或是有限集（如字母字符集），还是由多个数据项组成的复合数据元素（如学生基本表）
的集合，只要集合内元素的性质均相同，都可称之为一个数据对象。

4
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
1.2.2　数据结构
结构，本质上是一种组织关系，它揭示了元素间的相互联系和排列顺序。例如，分子结构
揭示了原子间的连接方式和排列序列；建筑结构则是由屋架、梁、板、柱等构件构成的，能够
承受各种外力的稳定框架。在计算机科学中，处理实际问题时，我们常观察到数据元素并非单
独存在，它们之间有着明确的关系。这些数据元素之间的相互作用和关联，被我们称作“结构”。
数据结构（Data Structure）是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，
数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。
数据结构包括逻辑结构和存储结构两个层次。逻辑结构是面向问题的，而存储结构是面向
计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机中。
1．逻辑结构
数据的逻辑结构是从逻辑关系上描述数
据，它与数据的存储无关，是独立于计算机
的。因此，数据的逻辑结构可以看作从具体
问题中抽象出来的数学模型，这是我们用计
算机求解问题的第一步。
数据的逻辑结构有两个要素：一是数据
元素；二是关系。数据元素的含义如前所述，
关系是指数据元素间的逻辑关系。根据数据
元素之间关系的不同特性，数据的逻辑结构
通常有4 类基本逻辑结构，如图 1.3 所示。它
们的复杂程度依次递进。
下面4 种结构中所举的示例是以某班级学生作为数据对象（数据元素是学生的学籍档案记
录），来分别考察数据元素之间的关系。
（1）集合结构
数据元素之间除了“属于同一集合”的关系外，别无其他关系。例如，确定一名学生是否
为班级成员，只需将班级看作一个集合结构。
（2）线性结构
数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报到的时间先后顺序
进行排列，将组成一个线性结构。
（3）树结构
数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位
组长管理多名组员，从而构成树结构。
（4）图结构或网状结构
数据元素之间存在多对多的关系。例如，多位同学之间的朋友关系，任何两位同学都可以
是朋友，从而构成图结构或网状结构。
其中集合结构、树结构和图结构或网状结构都属于非线性结构。
线性结构包括线性表（典型的线性结构，如例1.1 中的学生基本信息表）、栈和队列（具有
特殊限制的线性表，数据操作只能在表的一端或两端进行）、字符串（也是特殊的线性表，其特
殊性表现在它的数据元素仅由一个字符组成）、数组（是线性表的推广，它的数据元素是一个线
图1.3　4 类基本逻辑结构

5
第
1
章
 
绪
论
性表）、广义表（也是线性表的推广，它的数据元素是一个线性表，但不同构，即或者是单元素，
或者是线性表）。非线性结构包括树结构[ 分为树（具有多个分支的层次结构）和二叉树（具有
两个分支的层次结构）]、图结构[ 分为有向图（一种图结构，边是顶点的有序对）和无向图（另
一种图结构，边是顶点的无序对）] 和集合结构。这几种逻辑结构可以用一个层次图描述，如 
图1.4 所示。
图1.4　逻辑结构层次图
2．存储结构
数据对象在计算机中的存储表示称为数据的存储结构，也称为物理结构。用计算机求解问
题的第一步（分析其逻辑结构）完成后，我们便可以借助计算机实现其存储结构，存储结构是
逻辑结构的存储映像。
（1）顺序存储结构
顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系的，通常
借助程序设计语言的数组类型来描述。
对于前面的“学生基本信息表”，假定每个结点（学生记录）占用50 个存储单元，数据从
0 号单元开始由低地址向高地址方向存储，对应的顺序存储结构如表1.2 所示。
表1.2　学生基本信息表的顺序存储结构
地址
学号
姓名
性别
籍贯
专业
0
060214201
杨阳
男
安徽
计算机科学与技术
50
060214202
薛林
男
福建
计算机科学与技术
100
060214215
王诗萌
女
吉林
计算机科学与技术
150
060214216
冯子晗
女
山东
计算机科学与技术
（2）链式存储结构
顺序存储结构要求所有的元素依次存放在一片连续的存储空间中，而链式存储结构，无须
占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放
后继元素的存储地址。所以链式存储结构通常借助于程序设计语言的指针类型来描述。
假定给前面的“学生基本信息表”中的每个结点附加一个“下一个结点地址”，即后继指针
字段，用于存放后继结点的首地址，则可得到如表 1.3 所示的链式存储结构。从表中可以看出，
每个结点占用两个连续的存储单元，一个存放结点的信息，另一个存放后继结点的首地址。

6
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
表1.3　学生基本信息表的链式存储结构
地址
学号
姓名
性别
籍贯
专业
后继结点的首地址
0
060214201
杨阳
男
安徽
计算机科学与技术
100
50
060214216
冯子晗
女
山东
计算机科学与技术
^
100
060214202
薛林
男
福建
计算机科学与技术
150
150
060214215
王诗萌
女
吉林
计算机科学与技术
50
为了更清楚地反映链式存储结构，可采用更直观的图来表示，如“学生基本信息表”的链
式存储结构可用如图1.5 所示的方式表示。
图1.5　学生基本信息表的链式存储结构示意
1.2.3　数据类型和抽象数据类型
1．数据类型
数据类型（Data Type）是高级程序设计语言中的一个基本概念，是一组性质相同的值的集
合和定义在此集合上的一组操作的总称，是某种程序设计语言中已实现的数据结构。前面提到
过顺序存储结构可以借助程序设计语言的数组类型来描述，链式存储结构可以借助指针类型来
描述，所以数据类型和数据结构的概念密切相关。
在程序设计语言中，每一个数据都属于某种数据类型。类型明显或隐含地规定了数据的取
值范围、存储方式以及允许进行的运算。例如，C 语言中的整型变量，其值集为某个区间上的
整数（区间大小依赖于不同的机器），定义在其上的操作为加、减、乘、除和取模等算术运算；
而实型变量也有自己的取值范围和相应运算，比如取模运算是不能用于实型变量的。程序设计
语言允许用户直接使用的数据类型由具体语言决定，数据类型反映了程序设计语言的数据描述
和处理能力。C 语言除了提供整型、实型、字符型等基本类型数据外，还允许用户自定义各种
类型数据，例如数组、结构体和指针等。在程序设计语言提供的数据类型的支持下，用户就可
以根据从问题中抽象出来的数学模型构造出新的数据结构，继而实现相应的算法。
2．抽象数据类型
抽象就是抽取出实际问题的本质。在处理复杂问题时，通常可以采用抽象化的方法来简化
问题及其解决过程。抽象化的核心在于屏蔽具体实现细节，通过隐藏非必要的复杂性，使我们
能够聚焦于整体框架和关键概念，进而提升我们理解和解决问题的效率。抽象不仅仅是一种技
术手段，更是一种科学思维方法，它帮助我们从宏观的角度审视问题，精准地锁定问题的核心
所在。这种科学思维方法的前提是我们能否准确地识别问题并对其进行深入剖析，这种能力不
是一蹴而就的，而是需要通过系统的训练和实践来逐步培育和提高。在数据结构和计算机专业

7
第
1
章
 
绪
论
课程的学习过程中，培养抽象思维能力至关重要，它将为我们深入理解和掌握数据组织与操作
的本质提供强有力的支撑。
在计算机中使用二进制数来表示数据，在汇编语言中则可给出各种数据的十进制表示，它
们是二进制数据的抽象，使用者在编程时可以直接使用，不必考虑实现细节。在高级语言中，
则给出更高一级的数据抽象，出现了数据类型，如整型、实型、字符型等，可以进一步利用这
些类型构造出线性表、栈、队列、树、图等复杂的抽象数据类型。
抽象数据类型（Abstract Data Type，ADT）一般指由用户定义的、表示应用问题的数学模
型，以及定义在这个模型上的一组操作的总称，具体包括3 个部分：数据对象、数据对象上关
系的集合以及对数据对象的基本操作的集合。
抽象数据类型的定义格式如下：
ADT 抽象数据类型名{
　 数据对象：〈数据对象的定义〉
　 数据关系：〈数据关系的定义〉
　 基本操作：〈基本操作的定义〉
}ADT 抽象数据类型名
其中，数据对象和数据关系的定义采用数学符号和自然语言描述，基本操作的定义格式为：
基本操作名（参数表）
　 初始条件：〈初始条件描述〉
　 操作结果：〈操作结果描述〉
基本操作有两种参数：赋值参数只为操作提供输入值；引用参数以“&”打头，除可提供输
入值外，还将返回操作结果。“初始条件”描述了操作执行之前数据结构和参数应满足的条件，
若初始条件为空，则省略。“操作结果”说明了操作正常完成之后，数据结构的变化状况和应返
回的结果。
抽象数据类型提供了一个逻辑上的框架，使得用户可以专注于数据的逻辑结构和操作，而
无需关心数据的具体存储和实现细节。这种抽象层次允许用户以一种更高层次、更通用的方式
来思考和设计软件系统。
1.3　抽象数据类型的表示与实现
运用抽象数据类型描述数据结构，有助于在设计软件系统时，不必首先考虑其中包含的数
据对象，以及操作在不同处理器中的表示和实现细节，而是在构成软件系统的每个相对独立的
模块上定义一组数据和相应的操作，把这些数据的表示和操作细节留在模块内部解决，在更高
的层次上进行软件的分析和设计，从而提高软件的整体性能和利用率。
抽象数据类型的概念与面向对象方法的思想是一致的。抽象数据类型独立于具体实现，将
数据和操作封装在一起，使得用户程序只能通过抽象数据类型定义的某些操作来访问其中的数
据，从而实现了信息隐藏。在C++ 中，我们可以用类的声明表示抽象数据类型，用类的实现来
实现抽象数据类型。因此，C++ 中实现的类相当于数据的存储结构及其在存储结构上实现的对
数据的操作。
抽象数据类型和类的概念实际上反映了程序或软件设计的两层抽象：抽象数据类型相当于
在概念层（或称为抽象层）上描述问题，而类相当于在实现层上描述问题。此外，C++ 中的类
只是一个由用户定义的普通类型，可用它来定义变量（称为对象或类的实例）。因此，在C++
中，最终是通过操作对象来解决实际问题的，所以我们可将该层次看作应用层。例如，main 程
序就可看做是用户的应用程序。

8
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
由此可以看出，最终表示和实现抽象数据类型，最好用面向对象的方法，比如用C++ 语言
的类描述比较方便、有效，但本课程大多在大学低年级开设，用C 语言的描述方法更符合学生
的实际情况。另外，由于实际问题千变万化，数据模型和算法也形形色色，因此抽象数据类型
的设计和实现，就不可能像基本数据类型那样规范和一劳永逸。本书所讨论的数据结构及其算
法主要是面向读者的，故采用介于伪码和C 语言之间的类C 语言作为描述工具。这使得数据结
构与算法的描述与讨论简明清晰，不拘泥于C 语言的细节，又容易转换成C 或C++ 程序。
本书采用的类C 语言精选了C 语言的一个核心子集，同时做了若干扩充修改，增强了语言
的描述功能，以下对其做简要说明。
（1）预定义常量及类型：
// 函数结果状态代码
#deﬁne OK 1 
#deﬁne ERROR 0 
#deﬁne OVERFLOW -2 
//Status 是函数返回值类型，其值是函数结果状态代码。 
typedef int Status; 
（2）数据结构的表示（存储结构）用类型定义（typedef）描述；数据元素类型约定为
ElemType，由用户在使用该数据类型时自行定义。
（3）基本操作的算法都用如下格式的函数来描述： 
函数类型 函数名（函数参数表）
{
 　// 算法说明
 　语句序列
}// 函数名
当函数返回值为函数结果状态代码时，函数定义为Status 类型。为了便于描述算法，除了
值调用方式外，增加了C++ 语言引用调用的参数传递方式。在形参表中，以“&”打头的参数
即为引用参数。传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化，但引
用使用起来比指针更加方便、高效。 
（4）内存的动态分配与释放。
使用new 和delete 动态分配和释放内存空间：
分配空间　指针变量=new 数据类型;
释放空间　delete 指针变量;
（5）赋值语句：
简单赋值 变量名 = 表达式;
串联赋值 变量名1 = 变量名2 = ... = 变量名n = 表达式; 
成组赋值 ( 变量名1, ..., 变量名n) = ( 表达式1, ..., 表达式n); 
结构赋值　结构名1 = 结构名2;
 　　　　   结构名 = ( 值1, 值2, ..., 值n); 
条件赋值 变量名 = 条件表达式 ? 表达式T ：表达式F; 
交换赋值 变量名1 <--> 变量名2;
（6）选择语句：
条件语句1 if ( 表达式) 语句; 
条件语句2 if ( 表达式) 语句;
 　　　　   else 语句; 

9
第
1
章
 
绪
论
开关语句 switch ( 表达式)
　　　　　　 {　 
 　　　　　　　 case 值1: 语句序列1 ;break;
 　　　　　　　 case 值2: 语句序列2 ;break;
 　　　　　　　 …
 　　　　　　　 case 值n: 语句序列n;break;
 　　　　　　　 default: 语句序列n+1;
　　　　　　 }　 
（7）循环语句：
for 语句　　　　 for ( 表达式1; 条件; 表达式2) 语句; 
while 语句　　　while ( 条件) 语句; 
do-while 语句　   do {
 　　　　　　　　　　语句序列;
 　　　　　　　　　　} while ( 条件); 
（8）结束语句：
函数结束语句　　return 表达式; 
 　　　　　　　   return;
 　　　　　　　　case 或循环结束语句 break;
 　　　　　　　　异常结束语句 exit ( 异常代码);
（9）输入输出语句使用C++ 流式输入输出的形式：
输入语句 　　cin>> 变量1>>…>> 变量n; 
输出语句 　　cout<< 表达式1<<…<< 表达式n;
（10）基本函数：
求最大值　　Max ( 表达式1,…, 表达式n)
求最小值　　Min ( 表达式1,…, 表达式n)
下面以复数为例，给出一个完整的抽象数据类型的定义、表示和实现。
（1）定义部分：
ADT Complex {
　 数据对象：D={e1,e2|e1,e2 ∈R,R是实数集}
　 数据关系：S={<e1,e2>|e1 是复数的实部，e2 是复数的虚部}
　 基本操作：
　　 Creat(&C,x,y)
　　　 操作结果：构造复数C，其实部和虚部分别被赋予参数x和y的值。
　　 GetReal(C)
　　　 初始条件：复数C已存在。
　　　 操作结果：返回复数C的实部值。
　　 GetImag(C)
　　　 初始条件：复数C已存在。
　　　 操作结果：返回复数C的虚部值。
　　 Add(C1,C2)
　　　 初始条件：C1，C2是复数。
　　　 操作结果：返回两个复数C1和C2的和。
　　 Sub(C1,C2)
　　　 初始条件：C1，C2是复数。
　　　 操作结果：返回两个复数C1和C2的差。

10
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
} ADT Complex
在后文中，每定义一个新的数据结构，都先用这种定义方式给出其抽象数据类型的定义，
对于数据结构的表示方法，则根据不同的存储结构相应给出，同时用类C 语言给出主要操作的
实现方法。下面为了让读者对抽象数据类型有一个完整、正确的理解，给出复数的存储表示和
相应操作的具体实现过程。
（2）表示部分：
typedef struct  
 
//复数类型
{　
　 ﬂoat Realpart;　 
 
// 实部
　 ﬂoat Imagepart; 
 
//虚部
}Complex;
（3）实现部分：
void Create(&Complex C, ﬂoat x, ﬂoat y) 
{// 构造一个复数
　C.Realpart=x;
　C.Imagepart=y;
}
ﬂoat GetReal(Complex C) 
{// 取复数C=x+yi 的实部
　return C.Realpart;
}
ﬂoat GetImag(Complex C) 
{// 取复数C=x+yi 的虚部
　return C.Imagepart;
}
Complex Add(Complex C1, Complex C2) 
{ // 求两个复数C1和C2的和sum
 　Complex sum;
 　sum.Realpart=C1.Realpart+C2.Realpart;
 　sum.Imagepart=C1.Imagepart+C2.Imagepart;
 　return sum;
}
Complex Sub(Complex C1, Complex C2) 
{ // 求两个复数C1和C2的差difference
 　Complex difference;
 　difference.Realpart=C1.Realpart-C2.Realpart;
 　difference.Imagepart=C1.Imagepart-C2.Imagepart;
 　return difference;
}
这样定义之后，就可以在主程序中通过调用Create 函数构造一个复数，调用Add 或Sub 函
数实现复数的加法或减法运算，从而使用户可以像使用整数类型那样使用复数类型了。通过上
述实例，读者可以对抽象数据类型的概念有更加深刻的理解。
1.4　算法和算法分析
数据结构与算法之间存在着本质联系。在研究某一类型的数据结构时，总要涉及其上施加
的运算。只有通过对所定义运算的研究，才能真正理解数据结构的定义和作用。而在研究具体
的运算时，又需要联系到该算法处理的对象和输出结果所对应的数据。也就是说，在“数据结

11
第
1
章
 
绪
论
构”的研究过程中，将遇到大量的算法问题，这些算法联系着数据在计算过程中的组织方式，
为了描述如何实现某种操作，常常需要设计算法，因而算法是研究数据结构的重要途径。
1.4.1　算法的定义及特性
算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列。
沃斯教授指出：程序= 数据结构+ 算法。这说明数据结构和算法是程序的两大要素，二者相
辅相成，缺一不可。程序设计的本质是为要处理的问题选择好的数据结构，同时在此结构上施加
一种好的算法。算法和数据结构不可分割，共同构成了程序设计世界的基石。如果把程序设计比
作建造房子的话，数据结构可以看作建筑工程中的建筑设计图，算法可以看作施工流程图。
一个算法必须满足以下5 个重要特性。
（1）输入。一个算法有0 个或多个输入。对绝大多数算法来说，输入参数都是必要的，当
用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。
对于简单的算法，数据也可以直接在程序中给定，如打印“hello world”，这时不需要任何输入
参数，因此算法的输入可以是0 个。
（2）输出。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出
的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。
（3）确定性。对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义
性，使算法的执行者或阅读者都能明确其含义及如何执行。
（4）有穷性。一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。
（5）可行性。算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现，
即算法描述中的每条指令都是可执行的。
1.4.2　评价算法优劣的基本标准
同一个现实问题，可以有多个解决问题的算法，不同的算法有各自的优缺点，采用哪种算
法呢？算法评价就帮助我们来解决这一问题。一个算法的优劣应该从以下几方面来评价。
（1）正确性。在合理的数据输入下，能够在有限的运行时间内得到正确的结果。
（2）可读性。一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。
可读性强的算法有助于人们对算法的理解，而难懂的算法容易隐藏错误，且难于调试和修改。
（3）健壮性。当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而
不会产生一些莫名其妙的输出结果。
（4）高效性。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，
可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。
时间复杂度和空间复杂度是衡量算法的两个主要指标。
追求程序正确性、可读性、健壮性、高效性的道路是永无止境的，随着技术的不断进步和
应用场景的不断变化，我们需要不断学习和探索新的方法以适应新的环境。同时，需要关注程
序设计的伦理和社会责任，尽可能避免对隐私和安全造成的潜在威胁。
1.4.3　算法的时间复杂度
算法效率分析的目的是看算法实际是否可行，并在同一问题存在多个算法时，可进行时间
和空间性能上的比较，权衡需求，以便从中挑选出较优算法。

12
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。事后统计法需要先将算
法实现，然后测算其时间和空间开销。这种方法的缺陷很显然，一是必须把算法转换成可执行
的程序，二是时空开销的测算结果依赖于计算机的软硬件等环境因素，这容易掩盖算法本身的
优劣。所以我们通常采用事前分析估算法，通过计算算法的渐近复杂度来衡量算法的效率。
1．问题规模和语句频度
不考虑计算机的软硬件等环境因素，影响算法时间代价的最主要因素是问题规模。问题
规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n 表示。问题规模
n 对不同的问题含义不同，例如，在排序运算中n 为参加排序的记录数，在矩阵运算中n 为
矩阵的阶数，在多项式运算中n 为多项式的项数，在集合运算中n 为集合中元素的个数，在
树的有关运算中n 为树的结点个数，在图的有关运算中n 为图的顶点数或边数。显然，n 越
大算法的执行时间越长。
一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条
语句的重复执行次数和执行一次所需时间的乘积。
一条语句的重复执行次数称作语句频度（Frequency Count）。
由于语句的执行要由源程序经编译程序翻译成目标代码，目标代码经装配再执行，因此语
句执行一次实际所需的具体时间是与机器的软、硬件环境（如机器速度、编译程序质量等）密
切相关的。所以，所谓的算法分析并非精确统计算法实际执行所需时间，而是针对算法中语句
的执行次数做出估计，从中得到算法执行时间的信息。
设每条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有
语句频度之和来度量。
【例1.4】　求两个n 阶矩阵的乘积算法。
for(i=1;i<=n;i++)　　　　　　　　　　　  
 
 
// 频度为n+1
　 for(j=1;j<=n;j++)　　　　　　　　　　  
 
 
// 频度为n*(n+1)
　 {
　　　 c[i][j]=0; 
　　　　　　　　　　　 
 
 
// 频度为n
2
　　　 for(k=1;k<=n;k++)　　　　　　　　 
 
 
// 频度为n
2 * (n+1)
　　　 c[i][j]=c[i][j]+a[i][k]*b[k][j]; 
 
 
// 频度为n
3
　 }
该算法中所有语句频度之和，是矩阵阶数n 的函数，用f(n) 表示之。换句话说，上例算法
的执行时间与f(n) 成正比。
f(n)=2n3+3n2+2n+1
2．算法的时间复杂度定义
对于例1.4 这种较简单的算法，可以直接计算出算法中所有语句的频度；但对于稍微复杂
一些的算法，计算所有语句的频度则通常是比较困难的，即便能够计算出，也可能是个非常复
杂的函数。因此，为了客观地反映一个算法的执行时间，可以只用算法中的“基本语句”的执
行次数来度量算法的工作量。所谓“基本语句”指的是算法中重复执行次数和算法的执行时间
成正比的语句，它对算法运行时间的贡献最大。通常，算法的执行时间是随问题规模增长而增
长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。这种情况下，我们只需要考
虑当问题规模充分大时，算法中基本语句的执行次数在渐近意义下的阶。如例1.4 中矩阵的乘积
算法，当n 趋向无穷大时，显然有
 
3
3
2
3
lim
( ) /
lim(2
3
2
1) /
2
n
n
f n
n
n
n
n
n
→
→
=
+
+
+
=
∞
∞

13
第
1
章
 
绪
论
即当n 充分大时，f(n) 和n3 之比是一个不等于0 的常数。即f(n) 和n3 是同阶的，或者说
f(n) 和n3 的数量级（Order of Magnitude）相同。在这里，我们用“O”来表示数量级，记作
T(n) = O(f(n)) = O(n3)。由此我们可以给出下述算法时间复杂度的定义。
一般情况下，算法中基本语句重复执行的次数是问题规模n 的某个函数f(n)，算法的时间量
度记作：
T(n) = O(f(n)) 
它表示随着问题规模n 的增大，算法执行时间的增长率和f(n) 的增长率相同，称作算法的
渐近时间复杂度，简称时间复杂度（Time Complexity）。
数学符号“O”的严格定义为：
若T(n) 和f(n) 是定义在正整数集合上的两个函数，则T(n) = O(f(n)) 表示存在正的常数C 和
n0，使得当n ≥n0 时都满足0 ≤T(n) ≤Cf(n)。
该定义说明了函数T(n) 和f(n) 具有相同
的增长趋势，并且T(n) 的增长至多趋向于函数
f(n) 的增长。符号“O”用来描述增长率的上
限，它表示当问题规模n>n0 时，算法的执行时
间不会超过f(n)，其直观的含义如图1.6 所示。
这意味着，在大“O”记号的意义下，函
数各项正的常系数可以忽略并等同于1，多项
式中的低次项均可忽略，只需保留最高次项。
大“O”记号的这些性质体现了对函数总体渐
进增长趋势的关注和刻画。
3．算法的时间复杂度分析举例
分析算法时间复杂度的基本方法为：
（1）找出所有语句中语句频度最大的那条语句作为基本语句；
（2）计算基本语句的频度得到问题规模n 的某个函数 f(n) ；
（3）f(n) 数量级用符号“O”表示即可。
具体计算数量级时，可以遵循以下定理。
定理1.1　若f(n) = amnm + am-1nm-1 + … + a1n + a0 是一个m 次多项式，则T(n) = O(nm)。
定理1.1 说明，在计算算法时间复杂度时，可以忽略所有低次幂项和最高次幂的系数，这
样可以简化算法分析，也体现出了增长率的含义。
若算法可用递归方法描述，则算法的时间复杂度通常可使用递归方程表示，此时将涉及递
归方程求解问题。有关递归算法的时间复杂度分析方法将在第3 章给出。
下面举例说明如何求非递归算法的时间复杂度。
【例1.5】　常量阶示例。
{x++;s=0;}
两条语句频度均为 1，算法的执行时间是一个与问题规模 n 无关的常数，所以算法的时间
复杂度为T(n) = O(1)，称为常量阶。
实际上，如果算法的执行时间不随问题规模n 的增长而增长，算法中语句频度就是某个常
数。即使这个常数再大，算法的时间复杂度都是O(1)。例如，对上面的程序进行如下改动：
for(i=0;i<10000;i++){x++;s=0;}
算法的时间复杂度仍然为O(1)。
执行次数
问题规模n
＜n0时增长
趋势不定
n0
O
Cf (n)
T (n)
图1.6　符号“O”的直观含义

14
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
【例1.6】　线性阶示例。
for(i=0;i<n;i++){x++;s=0;}
循环体内两条基本语句的频度均为f(n) = n，所以算法的时间复杂度为T(n) = O(n)，称为线性阶。
【例1.7】　平方阶示例。
(1)　x=0;y=0;
(2)　for(k=1;k<=n;k++)
(3)  　 x++;
(4)　for(i=1;i<=n;i++)
(5)   　for(j=1;j<=n;j++)
(6)     　　y++;
对循环语句只需考虑循环体中语句的执行次数，以上程序段中频度最大的语句是（6），其
频度为f(n)  = n2，所以该算法的时间复杂度为T(n) = O(n2)，称为平方阶。
多数情况下，当有若干个循环语句时，算法的时间复杂度是由最深层循环内的基本语句的
频度f(n) 决定的。 
【例1.8】　立方阶示例。
(1)　x=1;
(2)　for(i=1;i<=n;i++)
(3)     for(j=1;j<=i;j++)
(4)     　　for(k=1;k<=j;k++)
(5)       　　　x++;
显而易见，该程序段中频度最大的语句是（5），这条最深层循环内的基本语句的频度，依
赖于各层循环变量的取值，由内向外可分析出语句（5）的执行次数为：
1
1
1
1
1
1
1
(
1) / 2
[ (
1)(2
1) / 6
(
1) / 2] / 2
j
n
i
n
i
n
i
j
k
i
j
i
j
i i
n n
n
n n
=
=
=
=
=
=
=
=
+
=
+
+
+
+
∑∑∑∑∑
∑
则该算法的时间复杂度为T(n) = O(n3) ，称为立方阶。
【例1.9】　对数阶示例。
for(i=1;i<=n;i=i*2){x++;s=0;}
设循环体内两条基本语句的频度为f(n)，则有2f(n) ≤n，f(n) ≤log2n，所以算法的时间复杂
度为T(n) = O(log2n)，称为对数阶。
常见的时间复杂度按数量级递增排列依次为：常量阶O(1)、对数阶O(log2n)、线性阶O(n)、
线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……、k 次方阶O(nk)、指数阶O(2n) 等。
不同数量级的时间复杂度性状如图1.7 所示。一般情况下，随着n 的增大，T(n) 的增长较
慢的算法为较优的算法。显然，时间复杂度为指数阶O(2n) 的算法效率极低，当n 值稍大时就无
法应用。应该尽可能选择使用多项式阶O(nk) 的算法，而避免使用指数阶的算法。
图1.7　不同数量级的时间复杂度性状

15
第
1
章
 
绪
论
4．最好、最坏和平均时间复杂度
对于某些问题的算法，其基本语句的频度不仅仅与问题的规模相关，还依赖于其他因素。
在此仅举一例说明之。
【例1.10】　在一维数组a 中顺序查找某个值等于e 的元素，并返回其所在位置。
(1)　for(i=0;i<n;i++)
(2)　　　if(a[i]==e) return i+1;
(3)　return 0;
容易看出，此算法中语句（2）的频度不仅与问题规模n 有关，还与输入实例中数组a[i] 的
各元素值及e 的取值有关。假设在数组a[i] 中必定存在值等于e 的元素，则查找必定成功，且
for 循环内的语句的频度将随被找到的元素在数组中出现的位置不同而不同，最好情况是，每
次要找的值与e 相同的元素恰好就是数组中的第一个元素，则不论数组的规模多大，语句（2）
的频度f(n) = 1，最坏情况是，每次待查找的都是数组中最后一个元素，则语句（2）的频度
f(n) = n。而对于一个算法来说，需要考虑各种可能出现的情况，以及每一种情况出现的概率。
一般情况下，可假设待查找的元素在数组中所有位置上出现的可能性均相同，则可取语句（2）
的频度在最好情况与最坏情况下的平均值，即f(n) = n/2，作为它的度量。
此例说明，算法的时间复杂度不仅与问题的规模有关，还与问题的其他因素有关。再如某
些排序的算法，其执行时间与待排序记录的初始状态有关。因此，有时会对算法有最好、最坏
以及平均时间复杂度的评价。
称算法在最好情况下的时间复杂度为最好时间复杂度，是指算法计算量可能达到的最小值；
称算法在最坏情况下的时间复杂度为最坏时间复杂度，是指算法计算量可能达到的最大值；算
法的平均时间复杂度是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量
的加权平均值。
对算法时间复杂度的度量，人们更关心的是最坏情况下和平均情况下的时间复杂度。然而
在很多情况下，算法的平均时间复杂度难以确定。因此，通常只讨论算法在最坏情况下的时间
复杂度，即分析在最坏情况下，算法执行时间的上界。在本书后面内容中讨论的时间复杂度，
除特别指明外，均指最坏情况下的时间复杂度。
1.4.4　算法的空间复杂度
关于算法的存储空间需求，类似于算法的时间复杂度，我们采用渐近空间复杂度（Space 
Complexity）作为算法所需存储空间的量度，简称空间复杂度，它也是问题规模n 的函数，记作：
S(n) = O(f (n))
一般情况下，一个程序在机器上执行时，除了需要寄存本身所用的指令、常数、变量和输
入数据外，还需要一些对数据进行操作的辅助存储空间。其中，输入数据所占的具体存储量取
决于问题本身，与算法无关，这样只需分析该算法在实现时所需要的辅助空间就可以了。若算
法执行时所需要的辅助空间相对于输入数据量而言是个常数，则称这个算法在原地工作，辅助
空间为O(1)，本节中前面的示例都是如此。有的算法需要占用临时的工作单元数与问题规模n
有关，如第8 章介绍的归并排序算法就属于这种情况。
下面举一简单示例说明如何求算法的空间复杂度。
【例1.11】　数组逆序，将一维数组a 中的n 个数逆序存放到原数组中。
【算法1】
for(i=0;i<n/2;i++)

16
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
{　 t=a[i];
　　a[i]=a[n-i-1];
　　a[n-i-1]=t;
}
【算法2】
for(i=0;i<n;i++)
　　b[i]=a[n-i-1];
for(i=0;i<n;i++)
　　a[i]=b[i];
算法1 仅需要另外借助一个变量t，与问题规模n 大小无关，所以其空间复杂度为O(1)。
算法2 需要另外借助一个大小为n 的辅助数组b，所以其空间复杂度为O(n)。
对于一个算法，其时间复杂度和空间复杂度往往是相互影响的，当追求一个较好的时间复杂
度时，可能会导致占用较多的存储空间，即可能会使空间复杂度的性能变差，反之亦然。不过，
通常情况下，鉴于运算空间较为充足，人们都以算法的时间复杂度作为算法优劣的衡量指标。
1.5　小结
本章介绍了数据结构的基本概念和术语，以及算法和算法时间复杂度的分析方法，主要内
容如下。
（1）数据结构是一门研究非数值计算程序设计中的操作对象，以及这些对象之间的关系和
操作的学科。
（2）数据结构包括两个方面的内容：数据的逻辑结构和存储结构。同一逻辑结构采用不同
的存储方法，可以得到不同的存储结构。
① 逻辑结构是从具体问题中抽象出来的数学模型，从逻辑关系上描述数据，它与数据的存
储无关。根据数据元素之间关系的不同特性，数据的逻辑结构通常有4 类基本逻辑结构：集合
结构、线性结构、树结构和图结构。
② 存储结构是逻辑结构在计算机中的存储表示，有两类存储结构：顺序存储结构和链式存
储结构。
（3）抽象数据类型是指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上
的一组操作的总称，具体包括3 个部分：数据对象、数据对象上关系的集合，以及对数据对象
的基本操作的集合。
（4）算法是为了解决某类问题而规定的一个有限长的操作序列。算法具有5 个性质：有穷
性、确定性、可行性、输入和输出。一个算法的优劣应该从以下四方面来评价：正确性、可读
性、健壮性和高效性。
（5）算法分析的两个主要方面是算法的时间复杂度和空间复杂度，以考察算法的时间和空
间效率。一般情况下，鉴于运算空间较为充足，故将算法的时间复杂度作为分析的重点。算法
执行时间的数量级称为算法的渐近时间复杂度，T(n) = O(f(n))，它表示随着问题规模 n 的增大，
算法执行时间的增长率和f (n) 的增长率相同，简称时间复杂度。
学完本章后，读者应掌握数据结构相关的基本概念，包括数据、数据元素、数据项、数据
对象、数据结构、逻辑结构、存储结构等；重点掌握数据结构所含两个层次的具体含义及其相
互关系；了解抽象数据类型的定义、表示与实现方法；了解算法的特性和评价标准；重点掌握
算法时间复杂度的分析方法。

17
第
1
章
 
绪
论
习题
1．简述下列概念：数据、数据元素、数据项、数据对象、数据结构、逻辑结构、存储结构、
抽象数据类型。
2．试举一个数据结构的例子，叙述其逻辑结构和存储结构两个层次的含义及相互关系。
3．简述逻辑结构的4 种基本结构并画出它们的关系图。
4．存储结构由哪两种基本的存储方法实现？
5．选择题
（1）在数据结构中，从逻辑上可以把数据结构分成（　　）。
A．动态结构和静态结构  
 
B．紧凑结构和非紧凑结构
C．线性结构和非线性结构 
 
D．内部结构和外部结构
（2）与数据元素本身的形式、内容、相对位置、个数无关的是数据的（　　）。
A．存储结构 
 
 
 
B．存储实现 
C．逻辑结构　   
 
 
D．运算实现
（3）通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着（　　）。
A．数据具有同一特点
B．不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致
C．每个数据元素都一样
D．数据元素所包含的数据项的个数要相等
（4）以下说法正确的是（　　）。
A．数据元素是数据的最小单位
B．数据项是数据的基本单位
C．数据结构是带有结构的各数据项的集合
D．一些表面上很不相同的数据可以有相同的逻辑结构
（5）算法的时间复杂度取决于（　　）。
A．问题的规模  
 
 
B．待处理数据的初态
C．计算机的配置 
 
 
D．A 和B
（6）以下数据结构中，（　　）是非线性数据结构。
A．树  
B．字符串 
 
C．队列　　　  
D．栈
6．试分析下列各算法的时间复杂度。
（1）x=90; y=100;
 　　while(y>0)
 　　　 if(x>100)
 　　　　　{x=x-10;y--;}
 　　　 else x++;
（2）for(i=0; i<n; i++)
 　　　  for(j=0; j<m; j++)
 　　　　　 a[i][j]=0;
（3）s=0;
　　for(i=0; i<n; i++)
 　　　 for(j=0; j<n; j++)
　　　　　s+=B[i][j];

18
数
据
结
构
 
（
C
语
言
版
）
  
（
第
3
版
）
 
 　　sum=s;
（4）i=1;
　　while(i<=n)
　　　 i=i*3;
（5）x=0;
　　for(i=1; i<n; i++)
　　　 for(j=1; j<=n-i; j++)
　　　　　　x++;
（6）x=n; //n>1
　　y=0;
　　while(x>=(y+1)*(y+1))
　　　 y++;