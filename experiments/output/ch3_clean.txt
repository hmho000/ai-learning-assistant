第 章

栈 和 队 列 表中的“(”=“)”表示当左右括号相遇时，括号内的运算已经完成。为了便于实现，假设 每个表达式均以“#”开始，以“#”结束。所以“#”=“#”表示整个表达式求值完毕。“)”与 “(”、“#”与“)”以及“(”与“#”之间无优先关系，这是因为表达式中不允许它们相继出现， 一旦遇到这种情况，则可以认为出现了语法错误。在下面的讨论中，我们暂假定所输入的表达 式不会出现语法错误。
【案例实现】
可以使用两个工作栈实现表达式求值算法，一个称作OPTR，用以寄存运算符；另一个称 作OPND，用以寄存操作数或运算结果。
算法3.22 表达式求值 【算法步骤】
① 初始化OPTR 栈和OPND 栈，将表达式起始符“#”压入OPTR 栈。
② 读取表达式，读入第一个字符ch，如果表达式没有读取完毕至“#”或 OPTR 的栈顶元素不为“#”时，则循环执行以下操作。
 若ch 不是运算符，则压入OPND 栈，读入下一字符ch。
 若ch 是运算符，则根据OPTR 的栈顶元素和ch 的优先级比较结果，做不同的处理：  若小于，则将ch 压入OPTR 栈，读入下一字符ch ；
 若大于，则弹出OPTR 栈顶的运算符，从OPND 栈弹出两个数，进行相应运算，将结 果压入OPND 栈；
 若等于，则OPTR 的栈顶元素是“(”且ch 是“)”，这时弹出OPTR 栈顶的“(”，相当 于括号匹配成功，然后读入下一字符ch。
③ OPND 栈顶元素即表达式求值结果，返回此元素。
【算法描述】
char EvaluateExpression()
{// 算术表达式求值的算符优先算法，设OPTR和OPND分别为运算符栈和操作数栈
  InitStack(OPND);

// 初始化OPND栈
  InitStack(OPTR);

// 初始化OPTR栈
  Push(OPTR，'#');

// 将表达式起始符“#”压入OPTR栈
  cin>>ch;
  while(ch!='#'||GetTop(OPTR)!='#')
// 表达式未读完或OPTR的栈顶元素不为“#”
  {
   if(!In(ch)){Push(OPND,ch);cin>>ch;}
//ch 不是运算符则进OPND栈
   else
     switch(Precede(GetTop(OPTR),ch))
// 比较OPTR的栈顶元素和ch的优先级
     {
      case '<':

        Push(OPTR,ch);cin>>ch;
// 当前字符ch压入OPTR栈，读入下一字符ch
        break;
      case '>':

        Pop(OPTR,theta);

// 弹出OPTR栈顶的运算符
        Pop(OPND,b);Pop(OPND,a);
// 弹出OPND栈顶的两个运算数
        Push(OPND,Operate(a,theta,b)); // 将运算结果压入OPND栈
        break;
      case '=':

//OPTR 的栈顶元素是“(”且ch是“)”
        Pop(OPTR,x);cin>>ch;

// 弹出OPTR栈顶的“(”，读入下一字符ch
        break;
     }

//switch
表达式求值

数 据 结 构

（ 第 版 ）

  }

//while
  return GetTop(OPND);

//OPND 栈顶元素即表达式求值结果
}
算法调用的3 个函数需要读者自行补充完成。其中In() 是判定读入的字符ch 是否为运算符 的函数，Precede() 是判定运算符栈的栈顶元素与读入的运算符之间优先关系的函数，Operate() 是进行二元运算的函数。
另外需要特别说明的是，上述算法中的操作数只能是一位数，因为这里使用的OPND 栈是 字符栈，如果要进行多位数的运算，则需要将OPND 栈改为数栈，即将读入的数字字符拼成数 之后再入栈。读者可以改进此算法，使之能完成多位数的运算。
【算法分析】
同算法3.21 一样，此算法从头到尾读取表达式中每个字符，若表达式的字符串长度为 n，则此算法的时间复杂度为O(n)。算法在运行时所占用的辅助空间主要取决于OPTR 栈和 OPND 栈的大小，显然，它们的空间大小之和不会超过n，所以此算法的空间复杂度也同样 为O(n)。
【例3.2】 算法表达式的求值过程。
利用算法3.22 对算术表达式3*(7−2) 进行求值，给出其求值的具体过程。
在表达式两端先增加“#”，将其改写为 #3*(7 −2)# 具体操作过程如表3.2 所示。
表3.2 算术表达式3*(7−2) 求值的具体操作过程 步骤 OPTR栈 OPND栈 读入字符 主要操作 # 3*(7−2)# Push(OPND,‘3’) # *(7−2)# Push(OPTR,‘*’) #* (7−2)# Push(OPTR,‘(’) #*( 7−2)# Push(OPND，‘7’) #*( 3 7 −2)# Push(OPTR，‘-’) #*(− 3 7 2)# Push(OPND，‘2’) #*(− 3 7 2 )# Push(OPND，Operate(‘7’，‘-’，‘2’)) #*( 3 5 )#
Pop(OPTR){ 消去一对括号}
#* 3 5 # Push(OPND，Operate(‘3’，‘*’，‘5’)) # # return(GetTop(OPND)) 在高级语言的编译处理过程中，实际上不只是表达式求值可以借助栈来实现，高级语言中 一般语法成分的分析都可以借助栈来实现，在编译原理课程中会涉及栈在语法、语义等分析算 法中的应用。
案例3.4 ：舞伴问题。
【案例分析】
对于舞伴配对问题，先入队的男士或女士先出队配成舞伴，因此设置两个队列分别存放男 士和女士入队者。假设男士和女士的记录存放在一个数组中作为输入，然后依次读取该数组的 各元素，并根据性别来决定是进入男队还是女队。当这两个队列构造完成之后，依次使两队当 前的队头元素出队来配成舞伴，直至某队列变空为止。此时，若某队仍有等待配对者，则输出 此队列中排在队头的等待者的姓名，此人将是下一轮舞曲开始时第一个可获得舞伴的人。